/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-05-25 14:48:53.975504
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKcos(j[2]);
x5=IKsin(j[2]);
x6=IKcos(j[3]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=((0.000799999744000123)*x8);
x11=((1.0)*x4);
x12=((0.000799999744000123)*x6);
x13=((0.999999680000154)*x6);
x14=((0.999999680000154)*x7);
x15=((0.055)*x5);
x16=((0.000799999744000123)*x5);
x17=((1.0)*x6);
x18=((1.0)*x5);
x19=((1.0)*x7);
x20=((0.999999680000154)*x4);
x21=((0.000799999744000123)*x7);
x22=((0.000799999744000123)*x4);
x23=((0.999999680000154)*x8);
x24=((0.097)*x5);
x25=((0.097)*x4);
x26=((0.055)*x4);
x27=((0.999999680000154)*x5);
x28=((-0.055)*x5);
x29=(x0*x1);
x30=(x0*x3);
x31=(x3*x5);
x32=(x0*x9);
x33=(x1*x2);
x34=(x1*x4);
x35=(x2*x3);
x36=(x3*x4);
x37=((-0.055)*x4);
x38=(x1*x5);
x39=((0.000799999744000123)*x35);
x40=((0.000799999744000123)*x30);
x41=((((-1.0)*x39))+x29);
x42=((((-1.0)*x29))+x39);
x43=((((-1.0)*x35))+(((0.000799999744000123)*x29)));
x44=(x33+x40);
x45=((((-0.0549999824000084)*x31))+(((0.0549999824000084)*x34)));
x46=((((-0.0969999689600149)*x34))+(((0.0969999689600149)*x31)));
x47=((((-2.23999928320034e-5)*x29))+(((0.028)*x35)));
x48=((((8.4799972864013e-5)*x29))+(((-0.106)*x35)));
x49=((((-1.0)*x30))+(((-0.000799999744000123)*x33)));
x50=((((-1.0)*x33))+(((-1.0)*x40)));
x51=((((-0.0549999824000084)*x36))+(((-0.0549999824000084)*x38)));
x52=((((-0.0969999689600149)*x38))+(((-0.0969999689600149)*x36)));
x53=((((8.4799972864013e-5)*x30))+(((0.106)*x33)));
x54=((((2.23999928320034e-5)*x30))+(((0.028)*x33)));
x55=(x4*x43);
x56=(x42*x5);
x57=(x4*x49);
x58=(x49*x5);
x59=(((x25*x44))+((x24*x43)));
x60=(((x26*x44))+((x15*x43)));
x61=(((x24*x50))+((x25*x43)));
IkReal x66=((1.0)*x3);
x62=(((x17*((((x1*x20))+(((-1.0)*x27*x66))))))+((x19*(((((-1.0)*x1*x27))+(((-1.0)*x20*x66)))))));
x63=(((x37*x43))+((x28*x50)));
x64=(((x17*(((((-1.0)*x5*x50))+(((-1.0)*x55))))))+((x19*((((x11*x44))+((x18*x43)))))));
x65=(x64*x8);
eetrans[0]=((0.122)+((x4*(((((2.23999928320034e-5)*x33))+(((0.028)*x30))))))+((x7*((((x26*x41))+((x15*x49))))))+((x6*((((x25*x41))+((x24*x49))))))+((x7*((((x25*x49))+((x24*x42))))))+((x4*(((((0.106)*x29))+(((-8.4799972864013e-5)*x35))))))+((x5*(((((0.028)*x29))+(((-2.23999928320034e-5)*x35))))))+(((0.165)*x29))+(((0.005)*x0))+(((-0.00013199995776002)*x35))+((x5*(((((-8.4799972864013e-5)*x33))+(((-0.106)*x30))))))+((x6*((((x28*x42))+((x37*x49)))))));
eetrans[1]=((0.000102399967232016)+(((-0.000131999915520054)*x3))+((x20*x47))+((x13*x59))+(((-8.47999457280347e-5)*x36))+(((-8.47999457280347e-5)*x38))+(((2.23999856640092e-5)*x34))+(((0.164999947200025)*x33))+((x13*x63))+((x27*x48))+((x14*x60))+((x14*x61))+((x27*x54))+((x12*x52))+((x20*x53))+((x21*x46))+((x12*x45))+(((-2.23999856640092e-5)*x31))+(((0.00499999840000077)*x2))+((x21*x51))+(((0.000131999915520054)*x30)));
IkReal x67=((1.0)*x22);
IkReal x68=((1.0)*x21);
IkReal x69=((1.0)*x12);
IkReal x70=((1.0)*x16);
eetrans[2]=((0.25199995904002)+(((-1.0)*x61*x68))+(((0.0279999820800115)*x34))+((x13*x52))+(((-1.0)*x53*x67))+((x14*x51))+(((-0.0279999820800115)*x31))+(((-1.0)*x54*x70))+(((-0.105999932160043)*x38))+(((-0.105999932160043)*x36))+(((-3.99999872000061e-6)*x2))+(((-1.0)*x47*x67))+((x14*x46))+(((-1.0)*x59*x69))+(((-1.05599932416043e-7)*x30))+(((-1.0)*x48*x70))+((x13*x45))+(((-0.164999894400068)*x3))+(((-0.00013199995776002)*x33))+(((-1.0)*x60*x68))+(((-1.0)*x63*x69)));
eerot[0]=((((0.999999680000154)*x2*x9))+(((-1.0)*x8*((((x17*((x57+x56))))+((x19*(((((-1.0)*x18*x49))+(((-1.0)*x11*x41)))))))))));
eerot[1]=(((x23*x64))+(((-0.99999936000041)*x32))+((x10*x62))+(((-6.39999590400262e-7)*x9)));
eerot[2]=(((x23*x62))+(((-1.0)*x10*x64))+(((0.000799999488000328)*x32))+(((-0.000799999488000328)*x9)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=((-0.122)+px);
new_r01=((((0.999999680000154)*r01))+(((-0.000799999744000123)*r02)));
new_py=((9.91999682560153e-5)+(((-0.000799999744000123)*pz))+(((0.999999680000154)*py)));
new_r02=((((0.000799999744000123)*r01))+(((0.999999680000154)*r02)));
new_pz=((-0.251999960320019)+(((0.000799999744000123)*py))+(((0.999999680000154)*pz)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j1eval[1];
j1eval[0]=((px*px)+(py*py));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x73 = IKatan2WithCheck(IkReal(((-0.999999680000154)*py)),IkReal(((0.999999680000154)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x73.valid){
continue;
}
IkReal x71=((1.0)*(x73.value));
if((((((0.99999936000041)*(py*py)))+(((0.99999936000041)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x74=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.99999936000041)*(py*py)))+(((0.99999936000041)*(px*px)))))),-1);
if(!x74.valid){
continue;
}
if( (((0.000799999744000123)*pz*(x74.value))) < -1-IKFAST_SINCOS_THRESH || (((0.000799999744000123)*pz*(x74.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x72=IKasin(((0.000799999744000123)*pz*(x74.value)));
j1array[0]=((((-1.0)*x71))+x72);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x71))+(((-1.0)*x72)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

IkReal op[4+1], zeror[4];
int numroots;
IkReal x75=px*px;
IkReal x76=py*py;
IkReal x77=pz*pz;
IkReal x78=(px*r01);
IkReal x79=(cj1*r01);
IkReal x80=((1.0)*r01);
IkReal x81=(r00*sj1);
IkReal x82=(cj1*r00);
IkReal x83=(px*py);
IkReal x84=(r01*sj1);
IkReal x85=(py*r01);
IkReal x86=((0.183603930309)*pz);
IkReal x87=((0.133337901678026)*pz);
IkReal x88=(py*sj1);
IkReal x89=(py*r00);
IkReal x90=((1.99999936000031)*pz);
IkReal x91=(pz*r02);
IkReal x92=(px*r00);
IkReal x93=((3.99999872000061)*pz);
IkReal x94=((0.0199999936000031)*pz);
IkReal x95=((1.99999936000031)*r02);
IkReal x96=((0.999999680000154)*r02);
IkReal x97=((0.476395858491101)*pz);
IkReal x98=(cj1*py);
IkReal x99=((0.203603923909003)*pz);
IkReal x100=((0.456395864891098)*pz);
IkReal x101=(px*sj1);
IkReal x102=((0.000106670321342421)*x78);
IkReal x103=((0.000106670321342421)*x89);
IkReal x104=((0.0773379443461477)*x85);
IkReal x105=((0.0773379443461477)*x91);
IkReal x106=((0.0773379443461477)*x92);
IkReal x107=((0.02)*x91);
IkReal x108=((0.02)*x85);
IkReal x109=((0.02)*x92);
IkReal x110=((1.59999948800025e-5)*x89);
IkReal x111=((1.59999948800025e-5)*x78);
IkReal x112=(sj1*x77);
IkReal x113=(cj1*px*r02);
IkReal x114=((2.0)*x75);
IkReal x115=(r02*x75);
IkReal x116=((0.00159999948800025)*x76);
IkReal x117=((0.000799999744000123)*x76);
IkReal x118=((0.00159999948800025)*x75);
IkReal x119=((2.0)*x76);
IkReal x120=((0.000799999744000123)*x75);
IkReal x121=(x82*x87);
IkReal x122=(x84*x87);
IkReal x123=((0.133337901678026)*x113);
IkReal x124=((0.133337901678026)*r02*x88);
IkReal x125=(x77*x96);
IkReal x126=(x90*x92);
IkReal x127=(x85*x90);
IkReal x128=(x76*x96);
IkReal x129=(x75*x96);
IkReal x130=(x77*x82);
IkReal x131=(x77*x84);
IkReal x132=(x75*x84);
IkReal x133=(x76*x82);
IkReal x134=(x77*x95);
IkReal x135=(x92*x93);
IkReal x136=((0.0199999936000031)*r02*x88);
IkReal x137=((0.0199999936000031)*x113);
IkReal x138=(x85*x93);
IkReal x139=(x84*x94);
IkReal x140=(x82*x94);
IkReal x141=(x76*x95);
IkReal x142=(x75*x95);
IkReal x143=(x76*x84);
IkReal x144=(x75*x82);
IkReal x145=((2.0)*x88*x91);
IkReal x146=((2.0)*x78*x98);
IkReal x147=((2.0)*x81*x83);
IkReal x148=((2.0)*cj1*px*x91);
IkReal x149=(x120*x79);
IkReal x150=((0.00159999948800025)*x78*x88);
IkReal x151=((0.000799999744000123)*x77*x79);
IkReal x152=((0.00159999948800025)*x101*x91);
IkReal x153=(x120*x81);
IkReal x154=((0.00159999948800025)*x82*x83);
IkReal x155=(x117*x79);
IkReal x156=((0.000799999744000123)*x77*x81);
IkReal x157=((0.00159999948800025)*x91*x98);
IkReal x158=(x117*x81);
IkReal x159=((2.0)*x131);
IkReal x160=((2.0)*x130);
IkReal x161=(x114*x84);
IkReal x162=(x119*x82);
IkReal x163=(x114*x82);
IkReal x164=((4.0)*x78*x98);
IkReal x165=((4.0)*cj1*px*x91);
IkReal x166=((4.0)*x81*x83);
IkReal x167=(x119*x84);
IkReal x168=((4.0)*x88*x91);
IkReal x169=((1.0)*x144);
IkReal x170=(sj1*x76*x80);
IkReal x171=((0.00319999897600049)*x101*x91);
IkReal x172=(x118*x79);
IkReal x173=(x118*x81);
IkReal x174=((0.00319999897600049)*x78*x88);
IkReal x175=((0.00159999948800025)*x77*x79);
IkReal x176=(x116*x81);
IkReal x177=((0.00319999897600049)*x82*x83);
IkReal x178=(x116*x79);
IkReal x179=((0.00159999948800025)*x77*x81);
IkReal x180=((0.00319999897600049)*x91*x98);
IkReal x181=((1.0)*x130);
IkReal x182=(sj1*x75*x80);
IkReal x183=((1.0)*x133);
IkReal x184=(x112*x80);
IkReal x185=(x143+x144);
IkReal x186=(x104+x105+x106);
IkReal x187=(x170+x169);
IkReal x188=(x124+x123+x103);
IkReal x189=(x122+x121+x102);
IkReal x190=(x131+x130+x133+x132);
IkReal x191=(x184+x181+x182+x183);
IkReal x192=(x145+x146+x147+x148);
IkReal x193=(x162+x160+x161+x159+x108+x109+x107);
IkReal x194=(x168+x163+x166+x167+x164+x165);
IkReal x195=(x157+x156+x155+x154+x158+x128+x129);
IkReal x196=(x153+x152+x151+x150+x149+x126+x127+x125);
IkReal x197=(x179+x178+x177+x176+x140+x141+x142+x139+x111+x180);
IkReal x198=(x171+x173+x172+x175+x174+x135+x134+x137+x136+x138+x110);
IkReal x199=((((0.0989855628116455)*x82))+(((0.0989855628116455)*x84))+(((-1.0)*x194))+x193+(((1.98487850268682e-5)*x79))+(((-0.0248109812835852)*r02))+(((-1.98487850268682e-5)*x81)));
IkReal x200=((((0.00896419559272961)*x82))+(((0.00896419559272961)*x84))+(((-1.0)*x194))+(((0.0262320456511062)*r02))+x193+(((2.0985636520885e-5)*x81))+(((-2.0985636520885e-5)*x79)));
IkReal x201=((((1.67830385412831e-5)*x79))+(((-1.0)*x187))+(((-1.0)*x188))+(((-0.395603989062249)*x91))+(((-0.395603989062249)*x92))+(((-1.0)*x192))+(((-0.395603989062249)*x85))+x190+x189+(((-1.67830385412831e-5)*x81))+(((-0.037909198648866)*x82))+(((-0.037909198648866)*x84))+(((-0.0209787981766039)*r02)));
IkReal x202=((((-0.0162598822583239)*x82))+(((-0.0162598822583239)*x84))+(((1.84181675017157e-5)*x81))+(((0.0230227093771447)*r02))+(((-1.0)*x187))+(((-1.0)*x188))+(((-1.84181675017157e-5)*x79))+(((-1.0)*x192))+(((0.264396010937751)*x92))+(((0.264396010937751)*x91))+x190+x189+(((0.264396010937751)*x85)));
IkReal x203=((((0.0223121771933842)*r02))+(((1.78497417547073e-5)*x81))+(((-1.78497417547073e-5)*x79))+(((-1.0)*x188))+(((-1.0)*x191))+x192+x185+x189+(((-0.415603989062249)*x85))+(((-0.415603989062249)*x92))+(((-0.415603989062249)*x91))+(((0.0419652385394885)*x82))+(((0.0419652385394885)*x84)));
IkReal x204=((((0.0137159221489464)*x82))+(((0.0137159221489464)*x84))+(((-1.0)*x188))+(((-0.0216893303603644)*r02))+(((-1.0)*x191))+x192+x185+x189+(((0.244396010937751)*x85))+(((0.244396010937751)*x92))+(((0.244396010937751)*x91))+(((1.73514642882915e-5)*x79))+(((-1.73514642882915e-5)*x81)));
IkReal x205=((((-0.0797744116605469)*r02))+(((-1.0)*x198))+(((0.043290989223098)*x82))+(((0.043290989223098)*x84))+x197+(((6.38195293284375e-5)*x79))+(((-6.38195293284375e-5)*x81)));
IkReal x206=((((-1.0)*x197))+x198+(((-2.39006358776141e-5)*x79))+(((2.39006358776141e-5)*x81))+(((0.0447120540453595)*x84))+(((0.0447120540453595)*x82))+(((0.0298757948470176)*r02)));
IkReal x207=((((4.14997958884766e-5)*x81))+(((-0.476395858491101)*x113))+((x82*x97))+(((-0.000381116686792881)*x89))+(((-1.0)*x186))+(((-1.0)*x196))+(((-4.14997958884766e-5)*x79))+(((0.0127921843332797)*x84))+(((0.0127921843332797)*x82))+x195+(((0.000381116686792881)*x78))+(((-0.476395858491101)*r02*x88))+(((0.0518747448605958)*r02))+((x84*x97)));
IkReal x208=((((-0.0120188048898182)*x82))+(((-0.0120188048898182)*x84))+(((-0.000365116691912878)*x89))+(((-0.456395864891098)*x113))+((x100*x82))+((x100*x84))+(((-0.0472107862436848)*r02))+(((-1.0)*x186))+(((-1.0)*x195))+(((3.77686289949478e-5)*x79))+(((-3.77686289949478e-5)*x81))+x196+(((-0.456395864891098)*r02*x88))+(((0.000365116691912878)*x78)));
IkReal x209=(((x82*x99))+(((-0.000162883139127203)*x89))+(((-0.203603923909003)*r02*x88))+(((-1.0)*x196))+(((4.40009278531137e-6)*x81))+(((-4.40009278531137e-6)*x79))+x195+x186+(((0.000162883139127203)*x78))+(((-0.0135027167444105)*x82))+(((-0.0135027167444105)*x84))+(((0.00550011598163922)*r02))+(((-0.203603923909003)*x113))+((x84*x99)));
IkReal x210=(((x84*x86))+(((-0.0035640767105492)*r02))+(((0.012729337300949)*x84))+(((0.012729337300949)*x82))+((x82*x86))+(((-1.0)*x195))+(((2.85126136843936e-6)*x79))+x196+x186+(((-0.183603930309)*r02*x88))+(((-0.183603930309)*x113))+(((-2.85126136843936e-6)*x81))+(((-0.0001468831442472)*x89))+(((0.0001468831442472)*x78)));
IkReal gconst0=x203;
IkReal gconst1=x205;
IkReal gconst2=x201;
IkReal gconst3=x207;
IkReal gconst4=x199;
IkReal gconst5=x208;
IkReal gconst6=x203;
IkReal gconst7=x205;
IkReal gconst8=x201;
IkReal gconst9=x207;
IkReal gconst10=x199;
IkReal gconst11=x208;
IkReal gconst12=x209;
IkReal gconst13=x200;
IkReal gconst14=x210;
IkReal gconst15=x202;
IkReal gconst16=x206;
IkReal gconst17=x204;
IkReal gconst18=x209;
IkReal gconst19=x200;
IkReal gconst20=x210;
IkReal gconst21=x202;
IkReal gconst22=x206;
IkReal gconst23=x204;
IkReal x211=((1.0)*gconst21);
IkReal x212=(gconst14*gconst20);
IkReal x213=(gconst13*gconst17);
IkReal x214=(gconst14*gconst4);
IkReal x215=(gconst18*gconst22);
IkReal x216=(gconst20*gconst21);
IkReal x217=(gconst0*gconst17);
IkReal x218=(gconst12*gconst5);
IkReal x219=(gconst21*gconst8);
IkReal x220=((1.0)*gconst9);
IkReal x221=(gconst15*gconst2);
IkReal x222=(gconst16*gconst2);
IkReal x223=(gconst10*gconst18);
IkReal x224=(gconst1*gconst17);
IkReal x225=(gconst2*gconst3);
IkReal x226=(gconst2*gconst4);
IkReal x227=(gconst19*gconst21);
IkReal x228=(gconst19*gconst5);
IkReal x229=(gconst11*gconst6);
IkReal x230=(gconst12*gconst17);
IkReal x231=(gconst8*gconst9);
IkReal x232=(gconst7*gconst9);
IkReal x233=(gconst14*gconst3);
IkReal x234=(gconst14*gconst15);
IkReal x235=(gconst23*gconst6);
IkReal x236=(gconst14*gconst16);
IkReal x237=(gconst10*gconst6);
IkReal x238=(gconst1*gconst5);
IkReal x239=(gconst18*gconst23);
IkReal x240=(gconst20*gconst9);
IkReal x241=(gconst13*gconst5);
IkReal x242=(gconst11*gconst18);
IkReal x243=(gconst21*gconst7);
IkReal x244=(gconst19*gconst9);
IkReal x245=(gconst0*gconst5);
IkReal x246=(gconst22*gconst6);
IkReal x247=((1.0)*x246);
IkReal x248=(gconst2*x244);
IkReal x249=(gconst7*x224);
IkReal x250=((1.0)*x245);
IkReal x251=(gconst23*x250);
op[0]=(((x234*x239))+(((-1.0)*x230*x239))+((x213*x215))+(((-1.0)*gconst15*x211*x212))+(((-1.0)*x215*x236))+((x227*x236))+((x216*x230))+(((-1.0)*gconst19*x211*x213)));
op[1]=(((x234*x235))+(((-1.0)*x223*x236))+((x230*x240))+((x222*x227))+(((-1.0)*x230*x235))+((x215*x224))+(((-1.0)*x215*x222))+((x234*x242))+(((-1.0)*gconst13*x211*x228))+((x216*x217))+((x216*x218))+(((-1.0)*gconst7*x211*x213))+((x214*x227))+((x236*x244))+((x236*x243))+(((-1.0)*gconst19*x211*x224))+((x233*x239))+((x213*x223))+(((-1.0)*gconst20*x211*x221))+(((-1.0)*x214*x215))+(((-1.0)*x230*x242))+((x219*x230))+(((-1.0)*x236*x247))+((x215*x241))+(((-1.0)*gconst3*x211*x212))+(((-1.0)*gconst15*x212*x220))+((x221*x239))+(((-1.0)*x217*x239))+(((-1.0)*gconst19*x213*x220))+(((-1.0)*x218*x239))+((x213*x246))+(((-1.0)*gconst8*x211*x234)));
op[2]=(((x221*x242))+((x218*x219))+((x218*x240))+(((-1.0)*gconst7*x213*x220))+((x229*x234))+((x233*x242))+(((-1.0)*x218*x242))+((x232*x236))+(((-1.0)*x215*x226))+(((-1.0)*x222*x247))+((x233*x235))+(((-1.0)*gconst20*x211*x225))+((x224*x246))+(((-1.0)*x239*x250))+((x216*x245))+((x230*x231))+((x223*x224))+(((-1.0)*x214*x247))+(((-1.0)*x229*x230))+(((-1.0)*gconst19*x220*x224))+(((-1.0)*gconst8*x211*x221))+((x225*x239))+(((-1.0)*x222*x223))+(((-1.0)*gconst7*x211*x241))+(((-1.0)*gconst8*x220*x234))+((x213*x237))+((x241*x246))+(((-1.0)*x236*x237))+((x221*x235))+((x226*x227))+((x215*x238))+(((-1.0)*gconst20*x220*x221))+(((-1.0)*x211*x249))+((x223*x241))+(((-1.0)*gconst3*x212*x220))+(((-1.0)*x217*x235))+((x217*x219))+((x222*x243))+((x222*x244))+((x214*x243))+((x214*x244))+((x217*x240))+(((-1.0)*x218*x235))+(((-1.0)*gconst13*x220*x228))+(((-1.0)*gconst1*x211*x228))+(((-1.0)*gconst8*x211*x233))+(((-1.0)*x217*x242))+(((-1.0)*x214*x223)));
op[3]=(((x226*x243))+((x226*x244))+(((-1.0)*x235*x250))+((x240*x245))+((x229*x233))+(((-1.0)*x226*x247))+(((-1.0)*gconst8*x220*x221))+(((-1.0)*x242*x250))+(((-1.0)*x220*x249))+((x237*x241))+((x217*x231))+((x238*x246))+((x218*x231))+(((-1.0)*gconst7*x220*x241))+((x222*x232))+(((-1.0)*gconst8*x211*x225))+((x225*x235))+(((-1.0)*x214*x237))+(((-1.0)*gconst8*x220*x233))+((x214*x232))+((x224*x237))+(((-1.0)*x218*x229))+(((-1.0)*gconst1*x220*x228))+((x221*x229))+(((-1.0)*x217*x229))+((x225*x242))+(((-1.0)*gconst20*x220*x225))+((x219*x245))+(((-1.0)*x222*x237))+(((-1.0)*x223*x226))+((x223*x238))+(((-1.0)*gconst7*x211*x238)));
op[4]=(((x237*x238))+((x225*x229))+(((-1.0)*x226*x237))+(((-1.0)*gconst7*x220*x238))+(((-1.0)*gconst8*x220*x225))+(((-1.0)*x229*x250))+((x226*x232))+((x231*x245)));
polyroots4(op,zeror,numroots);
IkReal j3array[4], cj3array[4], sj3array[4], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[4]={true,true,true,true};
_nj3 = 4;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
sj5array[0]=((((-0.999999680000154)*cj1*r01))+(((0.999999680000154)*r00*sj1))+(((-0.000799999744000123)*r02)));
if( sj5array[0] >= -1-IKFAST_SINCOS_THRESH && sj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKasin(sj5array[0]);
    cj5array[0] = IKcos(j5array[0]);
    sj5array[1] = sj5array[0];
    j5array[1] = j5array[0] > 0 ? (IKPI-j5array[0]) : (-IKPI-j5array[0]);
    cj5array[1] = -cj5array[0];
}
else if( isnan(sj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

IkReal op[6+1], zeror[6];
int numroots;
IkReal j2evalpoly[1];
IkReal x252=pz*pz;
IkReal x253=px*px;
IkReal x254=py*py;
IkReal x255=((0.00047348672)*cj3);
IkReal x256=(r01*sj1);
IkReal x257=(r01*sj3);
IkReal x258=(cj5*sj1);
IkReal x259=(cj1*r00);
IkReal x260=(cj3*px);
IkReal x261=(cj3*r02);
IkReal x262=(cj5*sj3);
IkReal x263=(r00*sj1);
IkReal x264=(cj1*py);
IkReal x265=(cj3*cj5);
IkReal x266=(cj1*cj5);
IkReal x267=((1.47059357741013e-6)*cj3);
IkReal x268=(py*sj3);
IkReal x269=(cj3*py);
IkReal x270=((0.0015816048)*sj3);
IkReal x271=((7.35296788705065e-7)*cj3);
IkReal x272=((0.00050133888)*cj3);
IkReal x273=(cj5*pz);
IkReal x274=(cj1*px);
IkReal x275=((0.00044563456)*cj3);
IkReal x276=((0.0004177824)*cj3);
IkReal x277=(cj1*r01);
IkReal x278=((0.00179248544)*sj3);
IkReal x279=(px*sj3);
IkReal x280=((0.00189792576)*sj3);
IkReal x281=((0.00168704512)*sj3);
IkReal x282=(r02*sj3);
IkReal x283=(pz*x282);
IkReal x284=((0.00932752)*px*x266);
IkReal x285=((0.00932752)*py*x258);
IkReal x286=((0.031632096)*x283);
IkReal x287=((0.031632096)*py*x257);
IkReal x288=((0.031632096)*r00*x279);
IkReal x289=((0.008355648)*r01*x269);
IkReal x290=((0.008355648)*pz*x261);
IkReal x291=((0.008355648)*r00*x260);
IkReal x292=((0.010544032)*py*x257);
IkReal x293=((0.010544032)*x283);
IkReal x294=((0.010544032)*r00*x279);
IkReal x295=((0.002785216)*r00*x260);
IkReal x296=((0.002785216)*pz*x261);
IkReal x297=((0.002785216)*r01*x269);
IkReal x298=((0.104904)*x252*x265);
IkReal x299=((0.102552)*x254*x262);
IkReal x300=((0.104904)*x253*x265);
IkReal x301=((0.102552)*x253*x262);
IkReal x302=((0.102552)*x252*x262);
IkReal x303=((0.104904)*x254*x265);
IkReal x304=((0.034184)*x253*x262);
IkReal x305=((0.034184)*x252*x262);
IkReal x306=((0.034968)*x252*x265);
IkReal x307=((0.034968)*x253*x265);
IkReal x308=((0.034184)*x254*x262);
IkReal x309=((0.034968)*x254*x265);
IkReal x310=(x285+x284);
IkReal x311=(x292+x293+x294);
IkReal x312=(x288+x287+x286);
IkReal x313=(x302+x303+x300+x301+x298+x299+x290+x291+x289);
IkReal x314=(x308+x309+x306+x307+x304+x305+x295+x296+x297);
IkReal x315=((((2.7836235572406e-6)*sj3*x263))+((x271*x277))+(((-1.0)*x263*x271))+(((-0.0186550340303901)*x273))+(((0.00347952944655076)*x282))+(((-1.84630980918096e-5)*x258*x260))+(((-2.7836235572406e-6)*cj1*x257))+(((1.80491462242741e-5)*x262*x264))+(((1.49240272243121e-5)*cj5*x264))+(((-1.49240272243121e-5)*px*x258))+(((-0.0225614327803427)*pz*x262))+(((-0.0230788726147619)*pz*x265))+(((-1.80491462242741e-5)*x258*x279))+(((-0.000919120985881332)*x261))+(((1.84630980918096e-5)*x264*x265)));
op[0]=(((x259*x281))+(((-0.000875603568)*x265))+(((-1.0)*x259*x275))+(((-0.000880267184)*x262))+(((-0.01118976)*x260*x266))+(((-0.01093888)*x258*x268))+(((-0.0014924032)*cj5))+x311+(((-0.01093888)*x262*x274))+(((-1.0)*x310))+(((-1.0)*x314))+((x256*x281))+(((-0.01118976)*x258*x269))+(((-1.0)*x256*x275)));
op[1]=x315;
op[2]=((((-0.002742205104)*x265))+((x259*x270))+(((-1.0)*x259*x276))+(((-0.0104904)*x258*x269))+(((-0.002753608752)*x262))+x312+(((-1.0)*x313))+(((-1.0)*x310))+(((-0.0102552)*x258*x268))+(((-0.0104904)*x260*x266))+(((-0.0045704848)*cj5))+((x256*x270))+(((-1.0)*x256*x276))+(((-0.0102552)*x262*x274)));
op[3]=((((-1.0)*x263*x267))+(((3.60982924485483e-5)*x262*x264))+(((-0.0461577452295239)*pz*x265))+(((5.56724711448121e-6)*sj3*x263))+(((-3.69261961836191e-5)*x258*x260))+(((-5.56724711448121e-6)*cj1*x257))+(((-0.0373100680607801)*x273))+(((2.98480544486241e-5)*cj5*x264))+(((-0.00183824197176266)*x261))+(((-3.60982924485483e-5)*x258*x279))+(((3.69261961836191e-5)*x264*x265))+(((-2.98480544486241e-5)*px*x258))+((x267*x277))+(((0.00695905889310151)*x282))+(((-0.0451228655606853)*pz*x262)));
op[4]=((((-0.00466376)*cj5))+((x259*x272))+(((0.01230624)*x262*x274))+(((-1.0)*x259*x280))+(((-0.002857599504)*x265))+(((0.01258848)*x258*x269))+x310+x312+(((0.01230624)*x258*x268))+(((-1.0)*x313))+(((-0.002866415952)*x262))+(((0.01258848)*x260*x266))+((x256*x272))+(((-1.0)*x256*x280)));
op[5]=x315;
op[6]=((((0.01188912)*x260*x266))+(((-1.0)*x259*x278))+(((0.01188912)*x258*x269))+(((0.01162256)*x258*x268))+x311+x310+(((-1.0)*x314))+(((-0.000993074384)*x262))+(((-0.000990997968)*x265))+(((-0.0015856784)*cj5))+((x255*x256))+((x255*x259))+(((-1.0)*x256*x278))+(((0.01162256)*x262*x274)));
polyroots6(op,zeror,numroots);
IkReal j2array[6], cj2array[6], sj2array[6], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[6]={true,true,true,true,true,true};
_nj2 = 6;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

j2evalpoly[0]=((((0.002785216)*cj1*px*sj3))+(((htj2*htj2*htj2*htj2*htj2*htj2)*(((((-0.01591552)*cj1*px*(cj3*cj3)))+(((0.0105440286259114)*pz*sj3))+(((-0.010544032)*cj3*py*sj1))+(((-0.01591552)*cj1*px*(sj3*sj3)))+(((-0.001252650896)*(sj3*sj3)))+(((-0.010544032)*cj1*cj3*px))+(((-0.01591552)*py*sj1*(cj3*cj3)))+(((2.22817208698505e-6)*cj1*cj3*py))+(((-0.001252650896)*(cj3*cj3)))+(((-0.002785216)*py*sj1*sj3))+(((-8.4352229007291e-6)*cj1*py*sj3))+(((-2.22817208698505e-6)*cj3*px*sj1))+(((-0.049736)*(pz*pz)*(sj3*sj3)))+(((8.4352229007291e-6)*px*sj1*sj3))+(((-0.049736)*(cj3*cj3)*(py*py)))+(((-0.002785216)*cj1*px*sj3))+(((-0.049736)*(cj3*cj3)*(pz*pz)))+(((-0.00044563456)*sj3))+(((-0.00168704512)*cj3))+(((-0.049736)*(cj3*cj3)*(px*px)))+(((-0.00278521510873131)*cj3*pz))+(((-0.049736)*(px*px)*(sj3*sj3)))+(((-0.049736)*(py*py)*(sj3*sj3)))+(((-0.01591552)*py*sj1*(sj3*sj3)))))))+(((-0.001416779696)*(cj3*cj3)))+(((0.010544032)*cj3*py*sj1))+(((0.01691024)*cj1*px*(sj3*sj3)))+(((htj2*htj2*htj2*htj2)*(((((0.0105440286259114)*pz*sj3))+(((-0.010544032)*cj3*py*sj1))+(((-0.00136475584)*sj3))+(((-0.0149208)*py*sj1*(sj3*sj3)))+(((-0.010544032)*cj1*cj3*px))+(((-0.149208)*(cj3*cj3)*(pz*pz)))+(((-0.149208)*(cj3*cj3)*(py*py)))+(((-0.149208)*(px*px)*(sj3*sj3)))+(((2.22817208698505e-6)*cj1*cj3*py))+(((-0.149208)*(cj3*cj3)*(px*px)))+(((-0.00516657568)*cj3))+(((-0.149208)*(pz*pz)*(sj3*sj3)))+(((-0.002785216)*py*sj1*sj3))+(((-0.0149208)*cj1*px*(cj3*cj3)))+(((-8.4352229007291e-6)*cj1*py*sj3))+(((-2.22817208698505e-6)*cj3*px*sj1))+(((-0.003922081488)*(cj3*cj3)))+(((-0.0149208)*cj1*px*(sj3*sj3)))+(((8.4352229007291e-6)*px*sj1*sj3))+(((-0.0149208)*py*sj1*(cj3*cj3)))+(((-0.002785216)*cj1*px*sj3))+(((-0.003922081488)*(sj3*sj3)))+(((-0.00278521510873131)*cj3*pz))+(((-0.149208)*(py*py)*(sj3*sj3)))))))+(((8.4352229007291e-6)*cj1*py*sj3))+(((-0.001416779696)*(sj3*sj3)))+(((0.01691024)*cj1*px*(cj3*cj3)))+(((htj2*htj2*htj2)*(((((-5.25211991932189e-5)*px*sj1*(sj3*sj3)))+(((-5.570432e-5)*cj3))+(((5.25211991932189e-5)*cj1*py*(cj3*cj3)))+(((0.011140864)*cj3*py*sj1))+(((8.91268834794018e-6)*cj1*py*sj3))+(((-0.0421761145036455)*cj3*pz))+(((-0.0111408604349252)*pz*sj3))+(((0.011140864)*cj1*cj3*px))+(((-0.0656514989915237)*pz*(sj3*sj3)))+(((-8.91268834794018e-6)*px*sj1*sj3))+(((-0.0656514989915237)*pz*(cj3*cj3)))+(((0.00021088064)*sj3))+(((5.25211991932189e-5)*cj1*py*(sj3*sj3)))+(((3.37408916029164e-5)*cj1*cj3*py))+(((-0.042176128)*py*sj1*sj3))+(((-0.042176128)*cj1*px*sj3))+(((-5.25211991932189e-5)*px*sj1*(cj3*cj3)))+(((-3.37408916029164e-5)*cj3*px*sj1))))))+(((htj2*htj2*htj2*htj2*htj2)*(((((-0.021088064)*py*sj1*sj3))+(((1.68704458014582e-5)*cj1*cj3*py))+(((-2.62605995966095e-5)*px*sj1*(cj3*cj3)))+(((0.005570432)*cj1*cj3*px))+(((2.62605995966095e-5)*cj1*py*(cj3*cj3)))+(((2.62605995966095e-5)*cj1*py*(sj3*sj3)))+(((-2.62605995966095e-5)*px*sj1*(sj3*sj3)))+(((-4.45634417397009e-6)*px*sj1*sj3))+(((-0.0328257494957618)*pz*(sj3*sj3)))+(((-0.0210880572518228)*cj3*pz))+(((4.45634417397009e-6)*cj1*py*sj3))+(((-1.68704458014582e-5)*cj3*px*sj1))+(((-0.0328257494957618)*pz*(cj3*cj3)))+(((0.00010544032)*sj3))+(((-0.00557043021746262)*pz*sj3))+(((-0.021088064)*cj1*px*sj3))+(((0.005570432)*cj3*py*sj1))+(((-2.785216e-5)*cj3))))))+(((2.22817208698505e-6)*cj3*px*sj1))+(((-0.049736)*(pz*pz)*(sj3*sj3)))+(((-0.0105440286259114)*pz*sj3))+(((0.00278521510873131)*cj3*pz))+((htj2*(((((-0.021088064)*py*sj1*sj3))+(((1.68704458014582e-5)*cj1*cj3*py))+(((-2.62605995966095e-5)*px*sj1*(cj3*cj3)))+(((0.005570432)*cj1*cj3*px))+(((2.62605995966095e-5)*cj1*py*(cj3*cj3)))+(((2.62605995966095e-5)*cj1*py*(sj3*sj3)))+(((-2.62605995966095e-5)*px*sj1*(sj3*sj3)))+(((-4.45634417397009e-6)*px*sj1*sj3))+(((-0.0328257494957618)*pz*(sj3*sj3)))+(((-0.0210880572518228)*cj3*pz))+(((4.45634417397009e-6)*cj1*py*sj3))+(((-1.68704458014582e-5)*cj3*px*sj1))+(((-0.0328257494957618)*pz*(cj3*cj3)))+(((0.00010544032)*sj3))+(((-0.00557043021746262)*pz*sj3))+(((-0.021088064)*cj1*px*sj3))+(((0.005570432)*cj3*py*sj1))+(((-2.785216e-5)*cj3))))))+(((0.01691024)*py*sj1*(sj3*sj3)))+(((-0.049736)*(cj3*cj3)*(py*py)))+(((htj2*htj2)*(((((0.01790496)*py*sj1*(sj3*sj3)))+(((0.002785216)*cj1*px*sj3))+(((-0.004086210288)*(sj3*sj3)))+(((0.01790496)*cj1*px*(sj3*sj3)))+(((-0.001392608)*sj3))+(((-0.005272016)*cj3))+(((-0.149208)*(cj3*cj3)*(pz*pz)))+(((-0.149208)*(cj3*cj3)*(py*py)))+(((-0.149208)*(px*px)*(sj3*sj3)))+(((0.010544032)*cj3*py*sj1))+(((-0.149208)*(cj3*cj3)*(px*px)))+(((8.4352229007291e-6)*cj1*py*sj3))+(((-0.149208)*(pz*pz)*(sj3*sj3)))+(((-0.004086210288)*(cj3*cj3)))+(((2.22817208698505e-6)*cj3*px*sj1))+(((-0.0105440286259114)*pz*sj3))+(((0.00278521510873131)*cj3*pz))+(((0.01790496)*cj1*px*(cj3*cj3)))+(((-2.22817208698505e-6)*cj1*cj3*py))+(((-8.4352229007291e-6)*px*sj1*sj3))+(((0.01790496)*py*sj1*(cj3*cj3)))+(((0.002785216)*py*sj1*sj3))+(((-0.149208)*(py*py)*(sj3*sj3)))+(((0.010544032)*cj1*cj3*px))))))+(((-0.00047348672)*sj3))+(((-0.049736)*(cj3*cj3)*(pz*pz)))+(((0.01691024)*py*sj1*(cj3*cj3)))+(((-0.049736)*(cj3*cj3)*(px*px)))+(((-2.22817208698505e-6)*cj1*cj3*py))+(((-8.4352229007291e-6)*px*sj1*sj3))+(((0.002785216)*py*sj1*sj3))+(((-0.00179248544)*cj3))+(((-0.049736)*(px*px)*(sj3*sj3)))+(((0.010544032)*cj1*cj3*px))+(((-0.049736)*(py*py)*(sj3*sj3))));
if( IKabs(j2evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4eval[2];
j4eval[0]=cj5;
j4eval[1]=IKsign(cj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x316=(sj2*sj3);
IkReal x317=((4.42335390059582)*pz);
IkReal x318=(cj2*cj3);
IkReal x319=(cj1*py);
IkReal x320=((7.80118778832354)*pz);
IkReal x321=(cj2*sj3);
IkReal x322=(cj3*sj2);
IkReal x323=((0.00624095023065883)*px*sj1);
IkReal x324=((7.80119028470323)*cj1*px);
IkReal x325=((7.80119028470323)*py*sj1);
IkReal x326=((0.00353868312047666)*px*sj1);
IkReal x327=((4.42335531606884)*cj1*px);
IkReal x328=((4.42335531606884)*py*sj1);
if( IKabs(((-0.250442335531607)+((x318*x327))+((x318*x328))+(((0.0221167765803442)*x316))+(((0.00624095023065883)*x318*x319))+(((-0.729853627151359)*cj3))+(((-1.0)*x321*x324))+(((-1.0)*x321*x326))+(((-1.0)*x321*x325))+(((-1.0)*x317*x321))+(((-1.0)*x317*x322))+(((-1.0)*x322*x324))+(((-1.0)*x322*x326))+(((-1.0)*x322*x325))+(((0.00353868312047666)*x319*x321))+(((0.00353868312047666)*x319*x322))+(((-1.0)*x316*x328))+(((-1.0)*x316*x327))+(((-1.0)*x318*x320))+(((-1.0)*x318*x323))+((x316*x323))+((x316*x320))+(((-0.00624095023065883)*x316*x319))+(((1.28719639697603)*sj3))+(((0.0390059514235162)*x321))+(((0.0390059514235162)*x322))+(((-0.0221167765803442)*x318)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.95078011902847)+((x318*x326))+((x318*x325))+((x318*x324))+(((-1.28719639697603)*cj3))+((x317*x318))+((x322*x327))+((x322*x328))+(((0.0390059514235162)*x316))+(((-0.729853627151359)*sj3))+(((0.00353868312047666)*x316*x319))+(((-1.0)*x321*x323))+(((-1.0)*x322*x323))+(((-1.0)*x320*x322))+(((-1.0)*x320*x321))+(((-0.0390059514235162)*x318))+(((-1.0)*x316*x324))+(((-1.0)*x316*x325))+(((-1.0)*x316*x326))+(((-0.00353868312047666)*x318*x319))+(((-0.0221167765803442)*x322))+(((-0.0221167765803442)*x321))+(((0.00624095023065883)*x319*x322))+(((0.00624095023065883)*x319*x321))+((x321*x328))+((x321*x327))+(((-1.0)*x316*x317)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.250442335531607)+((x318*x327))+((x318*x328))+(((0.0221167765803442)*x316))+(((0.00624095023065883)*x318*x319))+(((-0.729853627151359)*cj3))+(((-1.0)*x321*x324))+(((-1.0)*x321*x326))+(((-1.0)*x321*x325))+(((-1.0)*x317*x321))+(((-1.0)*x317*x322))+(((-1.0)*x322*x324))+(((-1.0)*x322*x326))+(((-1.0)*x322*x325))+(((0.00353868312047666)*x319*x321))+(((0.00353868312047666)*x319*x322))+(((-1.0)*x316*x328))+(((-1.0)*x316*x327))+(((-1.0)*x318*x320))+(((-1.0)*x318*x323))+((x316*x323))+((x316*x320))+(((-0.00624095023065883)*x316*x319))+(((1.28719639697603)*sj3))+(((0.0390059514235162)*x321))+(((0.0390059514235162)*x322))+(((-0.0221167765803442)*x318))))+IKsqr(((-0.95078011902847)+((x318*x326))+((x318*x325))+((x318*x324))+(((-1.28719639697603)*cj3))+((x317*x318))+((x322*x327))+((x322*x328))+(((0.0390059514235162)*x316))+(((-0.729853627151359)*sj3))+(((0.00353868312047666)*x316*x319))+(((-1.0)*x321*x323))+(((-1.0)*x322*x323))+(((-1.0)*x320*x322))+(((-1.0)*x320*x321))+(((-0.0390059514235162)*x318))+(((-1.0)*x316*x324))+(((-1.0)*x316*x325))+(((-1.0)*x316*x326))+(((-0.00353868312047666)*x318*x319))+(((-0.0221167765803442)*x322))+(((-0.0221167765803442)*x321))+(((0.00624095023065883)*x319*x322))+(((0.00624095023065883)*x319*x321))+((x321*x328))+((x321*x327))+(((-1.0)*x316*x317))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-0.250442335531607)+((x318*x327))+((x318*x328))+(((0.0221167765803442)*x316))+(((0.00624095023065883)*x318*x319))+(((-0.729853627151359)*cj3))+(((-1.0)*x321*x324))+(((-1.0)*x321*x326))+(((-1.0)*x321*x325))+(((-1.0)*x317*x321))+(((-1.0)*x317*x322))+(((-1.0)*x322*x324))+(((-1.0)*x322*x326))+(((-1.0)*x322*x325))+(((0.00353868312047666)*x319*x321))+(((0.00353868312047666)*x319*x322))+(((-1.0)*x316*x328))+(((-1.0)*x316*x327))+(((-1.0)*x318*x320))+(((-1.0)*x318*x323))+((x316*x323))+((x316*x320))+(((-0.00624095023065883)*x316*x319))+(((1.28719639697603)*sj3))+(((0.0390059514235162)*x321))+(((0.0390059514235162)*x322))+(((-0.0221167765803442)*x318))), ((-0.95078011902847)+((x318*x326))+((x318*x325))+((x318*x324))+(((-1.28719639697603)*cj3))+((x317*x318))+((x322*x327))+((x322*x328))+(((0.0390059514235162)*x316))+(((-0.729853627151359)*sj3))+(((0.00353868312047666)*x316*x319))+(((-1.0)*x321*x323))+(((-1.0)*x322*x323))+(((-1.0)*x320*x322))+(((-1.0)*x320*x321))+(((-0.0390059514235162)*x318))+(((-1.0)*x316*x324))+(((-1.0)*x316*x325))+(((-1.0)*x316*x326))+(((-0.00353868312047666)*x318*x319))+(((-0.0221167765803442)*x322))+(((-0.0221167765803442)*x321))+(((0.00624095023065883)*x319*x322))+(((0.00624095023065883)*x319*x321))+((x321*x328))+((x321*x327))+(((-1.0)*x316*x317))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x329=IKsin(j4);
IkReal x330=IKcos(j4);
IkReal x331=((0.106)*sj3);
IkReal x332=((0.028)*cj3);
IkReal x333=((0.028)*sj3);
IkReal x334=((0.106)*cj3);
IkReal x335=py*py;
IkReal x336=pz*pz;
IkReal x337=px*px;
IkReal x338=(px*sj1);
IkReal x339=((0.000799999744000123)*cj2);
IkReal x340=(py*sj1);
IkReal x341=((0.000799999744000123)*r02);
IkReal x342=(r02*sj2);
IkReal x343=((0.33)*cj2);
IkReal x344=(r00*sj1);
IkReal x345=(cj1*py);
IkReal x346=((0.000263999915520041)*sj2);
IkReal x347=(cj1*r01);
IkReal x348=(cj2*r02);
IkReal x349=(pz*r00);
IkReal x350=((0.000263999915520041)*cj2);
IkReal x351=(pz*sj2);
IkReal x352=(r01*sj1);
IkReal x353=(py*r01);
IkReal x354=((1.0)*cj2);
IkReal x355=(cj1*sj2);
IkReal x356=((7.99999744000123e-6)*r02);
IkReal x357=(py*r00);
IkReal x358=((0.00164999947200025)*cj2);
IkReal x359=((0.00499999840000077)*sj2);
IkReal x360=(px*r01);
IkReal x361=((0.999999680000154)*sj2);
IkReal x362=(cj1*px);
IkReal x363=((0.00499999840000077)*cj2);
IkReal x364=((0.329999894400051)*cj2);
IkReal x365=((0.999999680000154)*cj2);
IkReal x366=((0.000799999744000123)*sj2);
IkReal x367=((0.006228)*x329);
IkReal x368=((0.023644)*x330);
IkReal x369=((0.097)*x329);
IkReal x370=((0.999999680000154)*x337);
IkReal x371=((0.33)*x351);
IkReal x372=((1.99999936000031)*pz*r02);
IkReal x373=((0.055)*x330);
IkReal x374=((0.097)*x330);
IkReal x375=((0.999999680000154)*x335);
IkReal x376=((0.999999680000154)*x336);
IkReal x377=((0.055)*x329);
IkReal x378=(sj3*x374);
IkReal x379=(sj3*x377);
IkReal x380=(cj3*x369);
IkReal x381=(cj3*x373);
IkReal x382=(sj3*x369);
IkReal x383=(cj3*x374);
IkReal x384=(sj3*x373);
IkReal x385=(cj3*x377);
IkReal x386=(x332+x381);
IkReal x387=(x368+x367);
IkReal x388=(x331+x380+x379+x378);
IkReal x389=(x333+x334+x384+x385+x383);
evalcond[0]=(((px*x355))+((sj2*x340))+((x338*x339))+x388+((pz*x365))+(((-1.0)*x386))+(((-0.005)*sj2))+(((-1.0)*x339*x345)));
evalcond[1]=((0.165)+(((0.005)*cj2))+((x338*x366))+(((-1.0)*x354*x362))+(((-1.0)*x345*x366))+(((0.999999680000154)*x351))+x389+(((-1.0)*x382))+(((-1.0)*x340*x354)));
evalcond[2]=((-0.002796)+(((0.01)*x340))+((x343*x362))+(((0.01)*x362))+(((-0.329999894400051)*x351))+x387+((x345*x346))+(((-1.0)*x337))+(((-1.0)*x336))+(((-1.0)*x335))+((x340*x343))+(((-1.0)*x338*x346))+(((-0.00165)*cj2)));
evalcond[3]=((((-1.0)*px*x341*x355))+(((-1.0)*x360*x361))+(((-1.0)*x338*x348))+(((-1.0)*sj2*x340*x341))+x388+((x345*x348))+(((0.000799999744000123)*x349*x355))+(((-1.0)*x344*x359))+((x347*x359))+(((-1.0)*x386))+(((3.99999872000061e-6)*x342))+((x357*x361))+(((-1.0)*pz*x347*x354))+((cj2*pz*x344))+(((0.000799999744000123)*x351*x352)));
evalcond[4]=((((0.164999947200025)*x347))+(((-1.0)*r02*x339*x340))+(((0.00013199995776002)*r02))+((cj1*x339*x349))+(((-1.0)*x360*x365))+x382+((x347*x363))+((x347*x351))+(((-1.0)*r02*x339*x362))+((pz*x339*x352))+(((-1.0)*x389))+((x338*x342))+(((3.99999872000061e-6)*x348))+((x357*x365))+(((-1.0)*x342*x345))+(((-0.164999947200025)*x344))+(((-1.0)*x344*x363))+(((-1.0)*x344*x351)));
evalcond[5]=((-0.024454)+(((-1.0)*x347*x376))+(((-1.0)*x347*x370))+(((-1.0)*x347*x371))+(((0.33)*x342*x345))+(((-1.0)*pz*x350*x352))+(((-1.0)*x344*x370))+(((0.00159999948800025)*pz*x353))+(((-1.0)*x335*x341))+(((-1.0)*x338*x372))+((x336*x341))+(((0.000263999915520041)*x340*x348))+(((-1.99999936000031)*x338*x353))+(((1.99999936000031)*px*r00*x345))+(((-1.0)*x337*x341))+(((0.00999999680000153)*x360))+(((-1.0)*cj1*x349*x350))+(((-7.99999744000123e-6)*pz*x352))+((x347*x375))+((x344*x358))+((x344*x371))+((x344*x376))+((x344*x375))+((x356*x362))+(((-0.33)*x338*x342))+((x345*x372))+((x340*x356))+(((0.00159999948800025)*px*x349))+(((-7.99999744000123e-6)*cj1*x349))+(((0.000263999915520041)*x348*x362))+(((-1.0)*x347*x358))+(((-1.0)*x387))+(((-0.0272499912800042)*x347))+(((0.0272499912800042)*x344))+(((-1.0)*x357*x364))+((x360*x364))+(((-0.00999999680000153)*x357))+(((-2.17999930240033e-5)*r02))+(((-1.3199995776002e-6)*x348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x390=(sj2*sj3);
IkReal x391=((4.42335390059582)*pz);
IkReal x392=(cj2*cj3);
IkReal x393=(cj1*py);
IkReal x394=((7.80118778832354)*pz);
IkReal x395=(cj2*sj3);
IkReal x396=(cj3*sj2);
IkReal x397=((0.00624095023065883)*px*sj1);
IkReal x398=((7.80119028470323)*cj1*px);
IkReal x399=((7.80119028470323)*py*sj1);
IkReal x400=((0.00353868312047666)*px*sj1);
IkReal x401=((4.42335531606884)*cj1*px);
IkReal x402=((4.42335531606884)*py*sj1);
if( IKabs(((-0.250442335531607)+(((-0.729853627151359)*cj3))+(((0.0390059514235162)*x395))+(((0.0390059514235162)*x396))+((x392*x401))+((x392*x402))+(((0.0221167765803442)*x390))+(((0.00624095023065883)*x392*x393))+(((-1.0)*x395*x398))+(((-1.0)*x395*x399))+(((-1.0)*x395*x400))+(((-1.0)*x391*x395))+(((-1.0)*x391*x396))+(((0.00353868312047666)*x393*x395))+(((0.00353868312047666)*x393*x396))+(((-0.0221167765803442)*x392))+(((-1.0)*x396*x399))+(((-1.0)*x396*x398))+(((1.28719639697603)*sj3))+(((-1.0)*x396*x400))+((x390*x394))+((x390*x397))+(((-0.00624095023065883)*x390*x393))+(((-1.0)*x392*x394))+(((-1.0)*x392*x397))+(((-1.0)*x390*x402))+(((-1.0)*x390*x401)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.95078011902847)+(((-1.28719639697603)*cj3))+(((-0.0390059514235162)*x392))+(((-0.729853627151359)*sj3))+(((-1.0)*x394*x395))+(((-1.0)*x394*x396))+(((0.0390059514235162)*x390))+((x392*x400))+(((-1.0)*x395*x397))+(((0.00624095023065883)*x393*x395))+(((0.00624095023065883)*x393*x396))+(((0.00353868312047666)*x390*x393))+((x391*x392))+(((-0.0221167765803442)*x396))+(((-0.0221167765803442)*x395))+(((-1.0)*x396*x397))+((x395*x402))+((x395*x401))+(((-1.0)*x390*x391))+(((-1.0)*x390*x399))+(((-1.0)*x390*x398))+(((-0.00353868312047666)*x392*x393))+((x396*x402))+((x396*x401))+((x392*x399))+((x392*x398))+(((-1.0)*x390*x400)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.250442335531607)+(((-0.729853627151359)*cj3))+(((0.0390059514235162)*x395))+(((0.0390059514235162)*x396))+((x392*x401))+((x392*x402))+(((0.0221167765803442)*x390))+(((0.00624095023065883)*x392*x393))+(((-1.0)*x395*x398))+(((-1.0)*x395*x399))+(((-1.0)*x395*x400))+(((-1.0)*x391*x395))+(((-1.0)*x391*x396))+(((0.00353868312047666)*x393*x395))+(((0.00353868312047666)*x393*x396))+(((-0.0221167765803442)*x392))+(((-1.0)*x396*x399))+(((-1.0)*x396*x398))+(((1.28719639697603)*sj3))+(((-1.0)*x396*x400))+((x390*x394))+((x390*x397))+(((-0.00624095023065883)*x390*x393))+(((-1.0)*x392*x394))+(((-1.0)*x392*x397))+(((-1.0)*x390*x402))+(((-1.0)*x390*x401))))+IKsqr(((-0.95078011902847)+(((-1.28719639697603)*cj3))+(((-0.0390059514235162)*x392))+(((-0.729853627151359)*sj3))+(((-1.0)*x394*x395))+(((-1.0)*x394*x396))+(((0.0390059514235162)*x390))+((x392*x400))+(((-1.0)*x395*x397))+(((0.00624095023065883)*x393*x395))+(((0.00624095023065883)*x393*x396))+(((0.00353868312047666)*x390*x393))+((x391*x392))+(((-0.0221167765803442)*x396))+(((-0.0221167765803442)*x395))+(((-1.0)*x396*x397))+((x395*x402))+((x395*x401))+(((-1.0)*x390*x391))+(((-1.0)*x390*x399))+(((-1.0)*x390*x398))+(((-0.00353868312047666)*x392*x393))+((x396*x402))+((x396*x401))+((x392*x399))+((x392*x398))+(((-1.0)*x390*x400))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-0.250442335531607)+(((-0.729853627151359)*cj3))+(((0.0390059514235162)*x395))+(((0.0390059514235162)*x396))+((x392*x401))+((x392*x402))+(((0.0221167765803442)*x390))+(((0.00624095023065883)*x392*x393))+(((-1.0)*x395*x398))+(((-1.0)*x395*x399))+(((-1.0)*x395*x400))+(((-1.0)*x391*x395))+(((-1.0)*x391*x396))+(((0.00353868312047666)*x393*x395))+(((0.00353868312047666)*x393*x396))+(((-0.0221167765803442)*x392))+(((-1.0)*x396*x399))+(((-1.0)*x396*x398))+(((1.28719639697603)*sj3))+(((-1.0)*x396*x400))+((x390*x394))+((x390*x397))+(((-0.00624095023065883)*x390*x393))+(((-1.0)*x392*x394))+(((-1.0)*x392*x397))+(((-1.0)*x390*x402))+(((-1.0)*x390*x401))), ((-0.95078011902847)+(((-1.28719639697603)*cj3))+(((-0.0390059514235162)*x392))+(((-0.729853627151359)*sj3))+(((-1.0)*x394*x395))+(((-1.0)*x394*x396))+(((0.0390059514235162)*x390))+((x392*x400))+(((-1.0)*x395*x397))+(((0.00624095023065883)*x393*x395))+(((0.00624095023065883)*x393*x396))+(((0.00353868312047666)*x390*x393))+((x391*x392))+(((-0.0221167765803442)*x396))+(((-0.0221167765803442)*x395))+(((-1.0)*x396*x397))+((x395*x402))+((x395*x401))+(((-1.0)*x390*x391))+(((-1.0)*x390*x399))+(((-1.0)*x390*x398))+(((-0.00353868312047666)*x392*x393))+((x396*x402))+((x396*x401))+((x392*x399))+((x392*x398))+(((-1.0)*x390*x400))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x403=IKsin(j4);
IkReal x404=IKcos(j4);
IkReal x405=((0.028)*cj3);
IkReal x406=((0.106)*sj3);
IkReal x407=((0.028)*sj3);
IkReal x408=((0.106)*cj3);
IkReal x409=py*py;
IkReal x410=pz*pz;
IkReal x411=px*px;
IkReal x412=(px*sj1);
IkReal x413=((0.000799999744000123)*cj2);
IkReal x414=(py*sj1);
IkReal x415=((0.000799999744000123)*r02);
IkReal x416=(r02*sj2);
IkReal x417=((0.33)*cj2);
IkReal x418=(r00*sj1);
IkReal x419=(cj1*py);
IkReal x420=((0.000263999915520041)*sj2);
IkReal x421=(cj1*r01);
IkReal x422=(cj2*r02);
IkReal x423=(pz*r00);
IkReal x424=((0.000263999915520041)*cj2);
IkReal x425=(pz*sj2);
IkReal x426=(r01*sj1);
IkReal x427=(py*r01);
IkReal x428=((1.0)*cj2);
IkReal x429=(cj1*sj2);
IkReal x430=((7.99999744000123e-6)*r02);
IkReal x431=(py*r00);
IkReal x432=((0.00164999947200025)*cj2);
IkReal x433=((0.00499999840000077)*sj2);
IkReal x434=(px*r01);
IkReal x435=((0.999999680000154)*sj2);
IkReal x436=(cj1*px);
IkReal x437=((0.00499999840000077)*cj2);
IkReal x438=((0.329999894400051)*cj2);
IkReal x439=((0.999999680000154)*cj2);
IkReal x440=((0.000799999744000123)*sj2);
IkReal x441=((0.006228)*x403);
IkReal x442=((0.023644)*x404);
IkReal x443=((0.097)*x403);
IkReal x444=((0.999999680000154)*x411);
IkReal x445=((0.33)*x425);
IkReal x446=((1.99999936000031)*pz*r02);
IkReal x447=((0.055)*x404);
IkReal x448=((0.097)*x404);
IkReal x449=((0.999999680000154)*x409);
IkReal x450=((0.999999680000154)*x410);
IkReal x451=((0.055)*x403);
IkReal x452=(cj3*x447);
IkReal x453=(sj3*x448);
IkReal x454=(sj3*x451);
IkReal x455=(cj3*x443);
IkReal x456=(cj3*x448);
IkReal x457=(sj3*x447);
IkReal x458=(cj3*x451);
IkReal x459=(sj3*x443);
IkReal x460=(x405+x452);
IkReal x461=(x441+x442);
IkReal x462=(x406+x454+x455+x453);
IkReal x463=(x407+x408+x458+x456+x457);
evalcond[0]=(((sj2*x414))+((pz*x439))+(((-1.0)*x460))+x462+(((-0.005)*sj2))+((x412*x413))+(((-1.0)*x413*x419))+((px*x429)));
evalcond[1]=((0.165)+(((0.005)*cj2))+(((0.999999680000154)*x425))+((x412*x440))+(((-1.0)*x459))+x463+(((-1.0)*x414*x428))+(((-1.0)*x428*x436))+(((-1.0)*x419*x440)));
evalcond[2]=((-0.002796)+(((-1.0)*x412*x420))+(((-0.329999894400051)*x425))+((x414*x417))+((x419*x420))+x461+(((0.01)*x414))+(((0.01)*x436))+(((-0.00165)*cj2))+((x417*x436))+(((-1.0)*x409))+(((-1.0)*x410))+(((-1.0)*x411)));
evalcond[3]=(((x421*x433))+(((-1.0)*x412*x422))+(((-1.0)*x434*x435))+(((-1.0)*x462))+((x419*x422))+((cj2*pz*x418))+(((-1.0)*sj2*x414*x415))+(((-1.0)*pz*x421*x428))+x460+(((0.000799999744000123)*x425*x426))+(((-1.0)*px*x415*x429))+(((3.99999872000061e-6)*x416))+((x431*x435))+(((0.000799999744000123)*x423*x429))+(((-1.0)*x418*x433)));
evalcond[4]=((((-1.0)*r02*x413*x414))+((x421*x437))+(((3.99999872000061e-6)*x422))+(((0.00013199995776002)*r02))+((pz*x413*x426))+(((-1.0)*r02*x413*x436))+(((-1.0)*x416*x419))+(((-0.164999947200025)*x418))+(((-1.0)*x434*x439))+(((-1.0)*x459))+(((-1.0)*x418*x425))+(((0.164999947200025)*x421))+x463+((cj1*x413*x423))+((x431*x439))+((x412*x416))+(((-1.0)*x418*x437))+((x421*x425)));
evalcond[5]=((0.024454)+(((-7.99999744000123e-6)*pz*x426))+((x421*x449))+(((-0.0272499912800042)*x421))+((x414*x430))+((x418*x450))+(((-1.0)*x421*x432))+((x434*x438))+(((-1.0)*x431*x438))+(((-1.0)*pz*x424*x426))+(((-1.0)*x421*x444))+(((-1.0)*x421*x445))+(((0.00999999680000153)*x434))+((x410*x415))+(((0.000263999915520041)*x414*x422))+(((0.000263999915520041)*x422*x436))+((x418*x432))+x461+(((-1.3199995776002e-6)*x422))+(((-1.0)*cj1*x423*x424))+(((0.00159999948800025)*px*x423))+((x430*x436))+((x419*x446))+(((-0.00999999680000153)*x431))+(((0.33)*x416*x419))+((x418*x445))+((x418*x449))+(((0.0272499912800042)*x418))+(((-1.0)*x411*x415))+(((-1.0)*x421*x450))+(((1.99999936000031)*px*r00*x419))+(((-7.99999744000123e-6)*cj1*x423))+(((-1.0)*x412*x446))+(((-2.17999930240033e-5)*r02))+(((-0.33)*x412*x416))+(((-1.99999936000031)*x412*x427))+(((-1.0)*x418*x444))+(((0.00159999948800025)*pz*x427))+(((-1.0)*x409*x415)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x464=(r00*sj3);
IkReal x465=((0.000799999744000123)*sj1);
IkReal x466=(cj1*sj2);
IkReal x467=((0.000799999744000123)*r01);
IkReal x468=(cj2*sj3);
IkReal x469=(r01*sj1);
IkReal x470=(cj2*cj3);
IkReal x471=(sj2*sj3);
IkReal x472=(cj3*r00);
IkReal x473=((0.999999680000154)*r02);
IkReal x474=(cj3*sj2);
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x465*x472))+((cj1*x467*x468))+((x469*x470))+(((-1.0)*x468*x473))+(((-1.0)*x473*x474))+(((-1.0)*x464*x466))+((cj3*x466*x467))+(((-1.0)*x469*x471))+((cj1*r00*x470))+(((-1.0)*cj2*x464*x465)))),IkReal(((((-1.0)*cj1*x467*x470))+((x468*x469))+((x469*x474))+((x470*x473))+((x466*x472))+((cj1*cj2*x464))+(((-1.0)*x471*x473))+((sj3*x466*x467))+(((-1.0)*sj2*x464*x465))+((r00*x465*x470)))),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
CheckValue<IkReal> x476=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x476.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x475.value)+(((1.5707963267949)*(x476.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[12];
IkReal x477=IKcos(j4);
IkReal x478=IKsin(j4);
IkReal x479=py*py;
IkReal x480=pz*pz;
IkReal x481=px*px;
IkReal x482=(cj2*px);
IkReal x483=((0.000799999744000123)*sj1);
IkReal x484=(cj1*r02);
IkReal x485=((0.999999680000154)*px);
IkReal x486=(sj1*sj2);
IkReal x487=((0.165)*r01);
IkReal x488=(py*sj1);
IkReal x489=((0.097)*cj3);
IkReal x490=((0.000799999744000123)*r01);
IkReal x491=(px*r02);
IkReal x492=((0.028)*sj3);
IkReal x493=(cj3*cj5);
IkReal x494=(py*r01);
IkReal x495=(cj2*pz);
IkReal x496=((0.01)*r00);
IkReal x497=(py*r00);
IkReal x498=((7.99999744000123e-6)*sj2);
IkReal x499=(r00*sj1);
IkReal x500=((0.999999680000154)*r02);
IkReal x501=((0.33)*pz);
IkReal x502=(cj2*r00);
IkReal x503=(r00*sj2);
IkReal x504=(cj1*r01);
IkReal x505=((0.00013199995776002)*cj2);
IkReal x506=(r01*sj1);
IkReal x507=((2.0)*px);
IkReal x508=(cj5*sj3);
IkReal x509=((0.000799999744000123)*r02);
IkReal x510=(cj2*r02);
IkReal x511=((0.028)*cj3);
IkReal x512=(cj2*py);
IkReal x513=(cj1*r00);
IkReal x514=(px*r01);
IkReal x515=(pz*sj2);
IkReal x516=((0.00159999948800025)*px);
IkReal x517=(cj1*sj2);
IkReal x518=(pz*r00);
IkReal x519=(r02*sj1);
IkReal x520=((0.00159999948800025)*pz);
IkReal x521=((1.99999936000031)*pz);
IkReal x522=((1.0)*cj2);
IkReal x523=((2.0)*r02);
IkReal x524=((0.000799999744000123)*cj1);
IkReal x525=(r02*sj2);
IkReal x526=((2.17999930240033e-5)*cj2);
IkReal x527=(px*sj2);
IkReal x528=(px*r00);
IkReal x529=((0.00164999947200025)*cj2);
IkReal x530=((0.055)*cj3);
IkReal x531=((0.999999680000154)*pz);
IkReal x532=((1.0)*cj1);
IkReal x533=((0.00999999680000153)*pz);
IkReal x534=((0.106)*sj5);
IkReal x535=((0.00499999840000077)*cj2);
IkReal x536=((7.99999744000123e-6)*pz);
IkReal x537=(py*sj2);
IkReal x538=((0.00159999948800025)*py);
IkReal x539=(cj1*px);
IkReal x540=((0.165)*cj1);
IkReal x541=((0.01)*r02);
IkReal x542=((0.329999894400051)*pz);
IkReal x543=((0.006228)*x478);
IkReal x544=(sj2*x480);
IkReal x545=(cj2*x479);
IkReal x546=((0.999999680000154)*x481);
IkReal x547=(cj1*x481);
IkReal x548=(cj2*x480);
IkReal x549=(sj5*x477);
IkReal x550=(cj5*x477);
IkReal x551=(sj3*x478);
IkReal x552=(sj5*x478);
IkReal x553=((1.0)*x479);
IkReal x554=(cj5*x478);
IkReal x555=(sj3*x477);
IkReal x556=((0.999999680000154)*x479);
IkReal x557=((0.004068)*x478);
IkReal x558=((0.999999680000154)*x480);
IkReal x559=((0.004734)*x478);
IkReal x560=(x477*x508);
evalcond[0]=((((-1.0)*x477*x493))+((cj1*x503))+((cj2*x500))+((r01*x486))+((x478*x508))+(((-1.0)*cj1*cj2*x490))+((x483*x502)));
evalcond[1]=(((sj2*x500))+(((-1.0)*x490*x517))+(((-1.0)*x506*x522))+(((-1.0)*x502*x532))+x560+((x478*x493))+((x483*x503)));
evalcond[2]=((((-1.0)*x477*x530))+(((0.999999680000154)*x495))+((px*x517))+(((0.106)*sj3))+((py*x486))+((x478*x489))+(((-1.0)*x512*x524))+(((-0.005)*sj2))+((x482*x483))+(((0.097)*x555))+(((-1.0)*x511))+(((0.055)*x551)));
evalcond[3]=((0.165)+(((0.005)*cj2))+(((-0.097)*x551))+(((-1.0)*x482*x532))+((x478*x530))+(((0.999999680000154)*x515))+(((-0.000799999744000123)*py*x517))+(((-1.0)*x488*x522))+(((0.106)*cj3))+x492+((x483*x527))+(((0.055)*x555))+((x477*x489)));
evalcond[4]=((((0.00013199995776002)*sj2*x504))+(((0.028)*x550))+(((-1.0)*x528))+(((-0.164999947200025)*x525))+(((-0.00013199995776002)*r00*x486))+(((0.055)*cj5))+(((0.005)*x506))+((x502*x540))+(((-1.0)*x494))+(((0.106)*x554))+(((-1.0)*pz*r02))+((cj2*sj1*x487))+(((0.005)*x513)));
evalcond[5]=((-0.002796)+(((0.33)*cj1*x482))+(((0.33)*cj2*x488))+(((0.01)*x488))+(((0.01)*x539))+(((-1.0)*x481))+(((-1.0)*x480))+(((-1.0)*x553))+x543+(((0.000263999915520041)*py*x517))+(((-0.329999894400051)*x515))+(((-0.000263999915520041)*px*x486))+(((0.023644)*x477))+(((-0.00165)*cj2)));
evalcond[6]=((((-1.0)*x484*x485))+(((-1.0)*x488*x500))+(((3.99999872000061e-6)*x499))+(((0.164999947200025)*x510))+((px*x490))+((x513*x531))+((x503*x540))+(((-0.000799999744000123)*x497))+(((0.106)*x550))+(((-1.0)*x504*x505))+(((0.097)*cj5))+((x506*x531))+((x486*x487))+(((-3.99999872000061e-6)*x504))+((x499*x505))+(((-0.028)*x554))+(((0.00499999840000077)*r02)));
evalcond[7]=((((0.097)*sj3*x549))+(((0.055)*sj5*x551))+(((-0.000799999744000123)*x484*x527))+(((-1.0)*x530*x549))+((x495*x499))+(((-0.00499999840000077)*r00*x486))+(((3.99999872000061e-6)*x525))+((x489*x552))+((pz*x503*x524))+((sj3*x534))+(((-1.0)*sj5*x511))+(((-1.0)*x495*x504))+(((-1.0)*r01*sj2*x485))+(((-1.0)*py*x483*x525))+(((0.00499999840000077)*sj2*x504))+((r01*x483*x515))+(((-1.0)*x482*x519))+(((0.999999680000154)*sj2*x497))+((x484*x512)));
evalcond[8]=((((-0.000799999744000123)*x482*x484))+(((-1.0)*x530*x552))+(((0.00013199995776002)*r02))+(((-0.164999947200025)*x499))+(((0.999999680000154)*cj2*x497))+(((-1.0)*cj3*x534))+((r01*x483*x495))+(((-1.0)*x486*x518))+((x504*x515))+(((-0.055)*sj3*x549))+(((-1.0)*x489*x549))+(((-1.0)*sj5*x492))+(((0.097)*sj5*x551))+((x504*x535))+(((-1.0)*py*x483*x510))+(((-0.999999680000154)*r01*x482))+(((3.99999872000061e-6)*x510))+(((0.164999947200025)*x504))+(((-1.0)*x499*x535))+(((0.000799999744000123)*x495*x513))+(((-1.0)*x484*x537))+((x486*x491)));
evalcond[9]=((((-0.024454)*sj5))+(((0.00999999680000153)*x514))+(((-0.000263999915520041)*x495*x513))+(((-0.00999999680000153)*x497))+(((-0.023644)*x549))+((py*x484*x521))+(((7.99999744000123e-6)*r02*x488))+(((-1.0)*x504*x546))+((r00*x486*x501))+(((-1.0)*x504*x529))+(((-1.99999936000031)*x488*x514))+(((0.33)*x484*x537))+(((-1.0)*sj5*x543))+(((-1.0)*x479*x509))+(((-1.0)*x504*x558))+(((-0.000263999915520041)*x495*x506))+(((-1.0)*x481*x509))+(((-1.0)*x506*x536))+(((-0.329999894400051)*cj2*x497))+((x499*x556))+((x499*x558))+((x504*x556))+(((-0.33)*x486*x491))+(((1.99999936000031)*x497*x539))+(((7.99999744000123e-6)*px*x484))+(((-1.0)*x499*x546))+(((0.329999894400051)*r01*x482))+((x516*x518))+((x494*x520))+(((-1.0)*sj2*x501*x504))+(((0.000263999915520041)*x482*x484))+((x499*x529))+((x480*x509))+(((-1.0)*sj1*x491*x521))+(((-1.0)*x513*x536))+(((0.000263999915520041)*x488*x510))+(((-0.0272499912800042)*x504))+(((-2.17999930240033e-5)*r02))+(((-1.3199995776002e-6)*x510))+(((0.0272499912800042)*x499)));
evalcond[10]=((((-1.0)*x482*x496))+(((-0.01)*cj2*x494))+(((-1.0)*x495*x541))+(((2.17599930368033e-5)*sj2*x504))+(((2.0)*pz*x482*x484))+((x479*x483*x503))+(((-2.17599930368033e-5)*r00*x486))+(((-1.0)*x500*x544))+(((-0.00999999680000153)*x484*x527))+((x488*x495*x523))+(((-1.0)*x480*x506*x522))+(((-0.00999999680000153)*py*r02*x486))+(((-1.0)*x481*x490*x517))+((r01*x486*x533))+((cj1*x503*x533))+((x498*x514))+(((0.02725)*cj2*x506))+(((-1.0)*x481*x506*x522))+(((-1.99999936000031)*x494*x515))+(((-1.0)*x480*x502*x532))+(((0.016836)*x560))+(((-1.0)*x497*x498))+(((0.00165)*x513))+(((0.02725)*cj1*x502))+(((-1.0)*x493*x557))+(((-0.33)*x528))+(((-0.0271999912960042)*x525))+((x484*x515*x538))+((x502*x547))+(((-1.0)*x479*x502*x532))+(((-1.0)*x486*x491*x520))+((x508*x559))+(((2.0)*r00*x482*x488))+(((-0.017092)*x493))+(((-0.016606)*x477*x493))+((x497*x516*x517))+((x479*x490*x517))+((x506*x545))+(((-1.0)*x486*x494*x516))+(((2.0)*cj1*x482*x494))+(((-1.0)*x480*x490*x517))+(((-1.0)*px*x503*x521))+((sj2*x479*x500))+(((-0.33)*x494))+(((0.017484)*x508))+((sj2*x481*x500))+(((0.00165)*x506))+(((-1.0)*x481*x483*x503))+((x480*x483*x503))+(((-1.0)*r02*x501)));
evalcond[11]=((((-1.99999936000031)*x482*x518))+(((-7.99999744000123e-6)*cj2*x497))+(((-0.017092)*x508))+(((-1.0)*x482*x519*x520))+(((-1.0)*py*pz*x486*x523))+(((-0.00159999948800025)*r01*x482*x488))+(((-0.000263999915520041)*x497))+(((-1.0)*x486*x497*x507))+(((0.00999999680000153)*x495*x506))+(((0.0272)*cj1*x503))+((x479*x483*x502))+(((0.000263999915520041)*x514))+(((-1.0)*x500*x548))+((cj1*x480*x503))+(((0.01)*sj2*x494))+(((-1.3199995776002e-6)*x504))+(((-0.017484)*x493))+((x500*x545))+((r01*x481*x486))+(((-1.0)*x494*x507*x517))+(((-1.0)*x504*x526))+(((-0.00999999680000153)*x482*x484))+((x484*x495*x538))+((cj2*x481*x500))+(((1.3199995776002e-6)*x499))+(((-1.0)*x493*x559))+((x496*x527))+(((-1.0)*r01*x486*x553))+((x515*x541))+((r01*x480*x486))+(((-0.329999894400051)*r02*x488))+(((7.99999744000123e-6)*r01*x482))+(((-0.016836)*x477*x493))+((x513*x542))+(((-1.0)*x481*x503*x532))+(((-1.0)*x508*x557))+(((0.0272)*r01*x486))+(((0.0272499912800042)*x510))+(((-0.00999999680000153)*x488*x510))+(((-1.0)*cj1*x490*x548))+(((-1.99999936000031)*x494*x495))+(((-1.0)*x484*x507*x515))+((cj1*x479*x503))+(((-0.329999894400051)*px*x484))+(((0.00999999680000153)*x495*x513))+((x506*x542))+((x499*x526))+(((-1.0)*cj2*x490*x547))+(((-0.016606)*x560))+((cj1*x490*x545))+(((0.00159999948800025)*cj1*x482*x497))+(((0.00164999947200025)*r02))+(((-1.0)*x481*x483*x502))+((x480*x483*x502)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }
}
}
    }
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "4587f77697661977e41f95829c9a1215"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
