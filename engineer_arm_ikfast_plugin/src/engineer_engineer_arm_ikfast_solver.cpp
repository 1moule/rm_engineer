/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-05-21 18:59:09.000081
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKcos(j[2]);
x5=IKsin(j[2]);
x6=IKcos(j[3]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=((0.000799999744000123)*x8);
x11=((1.0)*x4);
x12=((0.000799999744000123)*x6);
x13=((0.999999680000154)*x6);
x14=((0.999999680000154)*x7);
x15=((0.055)*x5);
x16=((0.000799999744000123)*x5);
x17=((1.0)*x6);
x18=((1.0)*x5);
x19=((1.0)*x7);
x20=((0.999999680000154)*x4);
x21=((0.000799999744000123)*x7);
x22=((0.000799999744000123)*x4);
x23=((0.999999680000154)*x8);
x24=((0.097)*x5);
x25=((0.097)*x4);
x26=((0.055)*x4);
x27=((0.999999680000154)*x5);
x28=((-0.055)*x5);
x29=(x0*x1);
x30=(x0*x3);
x31=(x3*x5);
x32=(x0*x9);
x33=(x1*x2);
x34=(x1*x4);
x35=(x2*x3);
x36=(x3*x4);
x37=((-0.055)*x4);
x38=(x1*x5);
x39=((0.000799999744000123)*x35);
x40=((0.000799999744000123)*x30);
x41=((((-1.0)*x39))+x29);
x42=((((-1.0)*x29))+x39);
x43=((((-1.0)*x35))+(((0.000799999744000123)*x29)));
x44=(x33+x40);
x45=((((-0.0549999824000084)*x31))+(((0.0549999824000084)*x34)));
x46=((((-0.0969999689600149)*x34))+(((0.0969999689600149)*x31)));
x47=((((-2.23999928320034e-5)*x29))+(((0.028)*x35)));
x48=((((8.4799972864013e-5)*x29))+(((-0.106)*x35)));
x49=((((-1.0)*x30))+(((-0.000799999744000123)*x33)));
x50=((((-1.0)*x33))+(((-1.0)*x40)));
x51=((((-0.0549999824000084)*x36))+(((-0.0549999824000084)*x38)));
x52=((((-0.0969999689600149)*x38))+(((-0.0969999689600149)*x36)));
x53=((((8.4799972864013e-5)*x30))+(((0.106)*x33)));
x54=((((2.23999928320034e-5)*x30))+(((0.028)*x33)));
x55=(x4*x43);
x56=(x42*x5);
x57=(x4*x49);
x58=(x49*x5);
x59=(((x25*x44))+((x24*x43)));
x60=(((x26*x44))+((x15*x43)));
x61=(((x24*x50))+((x25*x43)));
IkReal x66=((1.0)*x3);
x62=(((x17*((((x1*x20))+(((-1.0)*x27*x66))))))+((x19*(((((-1.0)*x1*x27))+(((-1.0)*x20*x66)))))));
x63=(((x37*x43))+((x28*x50)));
x64=(((x17*(((((-1.0)*x5*x50))+(((-1.0)*x55))))))+((x19*((((x11*x44))+((x18*x43)))))));
x65=(x64*x8);
eetrans[0]=((0.122)+((x4*(((((2.23999928320034e-5)*x33))+(((0.028)*x30))))))+((x7*((((x26*x41))+((x15*x49))))))+((x6*((((x25*x41))+((x24*x49))))))+((x7*((((x25*x49))+((x24*x42))))))+((x4*(((((0.106)*x29))+(((-8.4799972864013e-5)*x35))))))+((x5*(((((0.028)*x29))+(((-2.23999928320034e-5)*x35))))))+(((0.165)*x29))+(((0.005)*x0))+(((-0.00013199995776002)*x35))+((x5*(((((-8.4799972864013e-5)*x33))+(((-0.106)*x30))))))+((x6*((((x28*x42))+((x37*x49)))))));
eetrans[1]=((0.000102399967232016)+(((-0.000131999915520054)*x3))+((x20*x47))+((x13*x59))+(((-8.47999457280347e-5)*x36))+(((-8.47999457280347e-5)*x38))+(((2.23999856640092e-5)*x34))+(((0.164999947200025)*x33))+((x13*x63))+((x27*x48))+((x14*x60))+((x14*x61))+((x27*x54))+((x12*x52))+((x20*x53))+((x21*x46))+((x12*x45))+(((-2.23999856640092e-5)*x31))+(((0.00499999840000077)*x2))+((x21*x51))+(((0.000131999915520054)*x30)));
IkReal x67=((1.0)*x22);
IkReal x68=((1.0)*x21);
IkReal x69=((1.0)*x12);
IkReal x70=((1.0)*x16);
eetrans[2]=((0.25199995904002)+(((-1.0)*x61*x68))+(((0.0279999820800115)*x34))+((x13*x52))+(((-1.0)*x53*x67))+((x14*x51))+(((-0.0279999820800115)*x31))+(((-1.0)*x54*x70))+(((-0.105999932160043)*x38))+(((-0.105999932160043)*x36))+(((-3.99999872000061e-6)*x2))+(((-1.0)*x47*x67))+((x14*x46))+(((-1.0)*x59*x69))+(((-1.05599932416043e-7)*x30))+(((-1.0)*x48*x70))+((x13*x45))+(((-0.164999894400068)*x3))+(((-0.00013199995776002)*x33))+(((-1.0)*x60*x68))+(((-1.0)*x63*x69)));
eerot[0]=((((0.999999680000154)*x2*x9))+(((-1.0)*x8*((((x17*((x57+x56))))+((x19*(((((-1.0)*x18*x49))+(((-1.0)*x11*x41)))))))))));
eerot[1]=(((x23*x64))+(((-0.99999936000041)*x32))+((x10*x62))+(((-6.39999590400262e-7)*x9)));
eerot[2]=(((x23*x62))+(((-1.0)*x10*x64))+(((0.000799999488000328)*x32))+(((-0.000799999488000328)*x9)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=((-0.122)+px);
new_r01=((((0.999999680000154)*r01))+(((-0.000799999744000123)*r02)));
new_py=((9.91999682560153e-5)+(((-0.000799999744000123)*pz))+(((0.999999680000154)*py)));
new_r02=((((0.000799999744000123)*r01))+(((0.999999680000154)*r02)));
new_pz=((-0.251999960320019)+(((0.000799999744000123)*py))+(((0.999999680000154)*pz)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0eval[1];
j0eval[0]=((px*px)+(py*py));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x73 = IKatan2WithCheck(IkReal(((-0.999999680000154)*py)),IkReal(((0.999999680000154)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x73.valid){
continue;
}
IkReal x71=((1.0)*(x73.value));
if((((((0.99999936000041)*(py*py)))+(((0.99999936000041)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x74=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.99999936000041)*(py*py)))+(((0.99999936000041)*(px*px)))))),-1);
if(!x74.valid){
continue;
}
if( (((0.000799999744000123)*pz*(x74.value))) < -1-IKFAST_SINCOS_THRESH || (((0.000799999744000123)*pz*(x74.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x72=IKasin(((0.000799999744000123)*pz*(x74.value)));
j0array[0]=((((-1.0)*x71))+x72);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x71))+(((-1.0)*x72)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

IkReal op[4+1], zeror[4];
int numroots;
IkReal x75=px*px;
IkReal x76=py*py;
IkReal x77=pz*pz;
IkReal x78=(px*r01);
IkReal x79=(r01*sj0);
IkReal x80=(cj0*r00);
IkReal x81=(cj0*r01);
IkReal x82=((0.183603930309)*pz);
IkReal x83=(py*r01);
IkReal x84=((2.0)*pz);
IkReal x85=(py*sj0);
IkReal x86=(px*r00);
IkReal x87=(r00*sj0);
IkReal x88=((0.999999680000154)*r02);
IkReal x89=((1.99999936000031)*pz);
IkReal x90=((0.476395858491101)*pz);
IkReal x91=((3.99999872000061)*pz);
IkReal x92=((0.0199999936000031)*pz);
IkReal x93=(pz*r02);
IkReal x94=(cj0*py);
IkReal x95=((0.456395864891098)*pz);
IkReal x96=((0.133337901678026)*pz);
IkReal x97=((1.99999936000031)*r02);
IkReal x98=((0.203603923909003)*pz);
IkReal x99=(px*py);
IkReal x100=(py*r00);
IkReal x101=(px*sj0);
IkReal x102=((0.000106670321342421)*x78);
IkReal x103=((0.000106670321342421)*x100);
IkReal x104=((0.0773379443461477)*x83);
IkReal x105=((0.0773379443461477)*x93);
IkReal x106=((0.0773379443461477)*x86);
IkReal x107=((0.02)*x93);
IkReal x108=((0.02)*x83);
IkReal x109=((0.02)*x86);
IkReal x110=((1.59999948800025e-5)*x100);
IkReal x111=((1.59999948800025e-5)*x78);
IkReal x112=((1.0)*x76);
IkReal x113=(cj0*px*r02);
IkReal x114=((0.000799999744000123)*x76);
IkReal x115=((2.0)*x75);
IkReal x116=((0.00159999948800025)*x75);
IkReal x117=((0.000799999744000123)*x77);
IkReal x118=((2.0)*x76);
IkReal x119=((0.000799999744000123)*x75);
IkReal x120=((1.0)*x77);
IkReal x121=((0.00159999948800025)*x76);
IkReal x122=((1.0)*x75);
IkReal x123=((2.0)*x77);
IkReal x124=((0.00159999948800025)*x77);
IkReal x125=(x80*x96);
IkReal x126=(x79*x96);
IkReal x127=((0.133337901678026)*r02*x85);
IkReal x128=((0.133337901678026)*x113);
IkReal x129=(x77*x88);
IkReal x130=(x86*x89);
IkReal x131=(x83*x89);
IkReal x132=(x76*x88);
IkReal x133=(x75*x88);
IkReal x134=(x77*x79);
IkReal x135=(x75*x79);
IkReal x136=(x76*x80);
IkReal x137=(x77*x80);
IkReal x138=(x77*x97);
IkReal x139=(x86*x91);
IkReal x140=((0.0199999936000031)*x113);
IkReal x141=((0.0199999936000031)*r02*x85);
IkReal x142=(x83*x91);
IkReal x143=(x79*x92);
IkReal x144=(x76*x97);
IkReal x145=(x75*x97);
IkReal x146=(x80*x92);
IkReal x147=(x75*x80);
IkReal x148=(x76*x79);
IkReal x149=(r02*x84*x85);
IkReal x150=((2.0)*x85*x86);
IkReal x151=((2.0)*x78*x94);
IkReal x152=(x113*x84);
IkReal x153=((0.00159999948800025)*x78*x85);
IkReal x154=((0.00159999948800025)*x101*x93);
IkReal x155=(x117*x81);
IkReal x156=(x119*x81);
IkReal x157=(x119*x87);
IkReal x158=(x114*x87);
IkReal x159=((0.00159999948800025)*x93*x94);
IkReal x160=((0.00159999948800025)*x80*x99);
IkReal x161=(x117*x87);
IkReal x162=(x114*x81);
IkReal x163=(x123*x79);
IkReal x164=(x115*x79);
IkReal x165=(x118*x80);
IkReal x166=(x123*x80);
IkReal x167=((4.0)*x85*x86);
IkReal x168=((4.0)*x78*x94);
IkReal x169=((4.0)*cj0*px*x93);
IkReal x170=(x118*x79);
IkReal x171=(x115*x80);
IkReal x172=((4.0)*x85*x93);
IkReal x173=(x122*x80);
IkReal x174=(x112*x79);
IkReal x175=(x116*x87);
IkReal x176=(x116*x81);
IkReal x177=(x124*x81);
IkReal x178=((0.00319999897600049)*x101*x93);
IkReal x179=((0.00319999897600049)*x78*x85);
IkReal x180=(x124*x87);
IkReal x181=(x121*x87);
IkReal x182=(x121*x81);
IkReal x183=((0.00319999897600049)*x80*x99);
IkReal x184=((0.00319999897600049)*x93*x94);
IkReal x185=(x122*x79);
IkReal x186=(x120*x80);
IkReal x187=(x112*x80);
IkReal x188=(x120*x79);
IkReal x189=(x147+x148);
IkReal x190=(x104+x105+x106);
IkReal x191=(x173+x174);
IkReal x192=(x126+x125+x102);
IkReal x193=(x127+x128+x103);
IkReal x194=(x135+x134+x137+x136);
IkReal x195=(x152+x151+x150+x149);
IkReal x196=(x185+x186+x187+x188);
IkReal x197=(x163+x166+x164+x165+x108+x109+x107);
IkReal x198=(x171+x170+x172+x168+x169+x167);
IkReal x199=(x162+x160+x161+x159+x158+x133+x132);
IkReal x200=(x157+x156+x155+x154+x153+x131+x130+x129);
IkReal x201=(x143+x144+x145+x146+x111+x184+x180+x181+x182+x183);
IkReal x202=(x190+x200);
IkReal x203=(x179+x178+x175+x177+x176+x140+x141+x142+x139+x138+x110);
IkReal x204=((((0.0989855628116455)*x79))+(((0.0989855628116455)*x80))+(((-1.0)*x198))+(((1.98487850268682e-5)*x81))+x197+(((-0.0248109812835852)*r02))+(((-1.98487850268682e-5)*x87)));
IkReal x205=((((0.00896419559272961)*x79))+(((0.00896419559272961)*x80))+(((-1.0)*x198))+(((0.0262320456511062)*r02))+x197+(((2.0985636520885e-5)*x87))+(((-2.0985636520885e-5)*x81)));
IkReal x206=((((-0.395603989062249)*x93))+(((-1.0)*x193))+(((-1.0)*x195))+(((-1.0)*x191))+(((-0.395603989062249)*x83))+(((-0.395603989062249)*x86))+x192+x194+(((1.67830385412831e-5)*x81))+(((-1.67830385412831e-5)*x87))+(((-0.037909198648866)*x80))+(((-0.037909198648866)*x79))+(((-0.0209787981766039)*r02)));
IkReal x207=((((-0.0162598822583239)*x80))+(((1.84181675017157e-5)*x87))+(((0.0230227093771447)*r02))+(((-0.0162598822583239)*x79))+(((-1.0)*x193))+(((-1.0)*x195))+(((-1.0)*x191))+(((-1.84181675017157e-5)*x81))+(((0.264396010937751)*x93))+x192+x194+(((0.264396010937751)*x86))+(((0.264396010937751)*x83)));
IkReal x208=((((0.0223121771933842)*r02))+(((1.78497417547073e-5)*x87))+(((-1.78497417547073e-5)*x81))+(((-1.0)*x193))+(((-1.0)*x196))+x192+x195+x189+(((-0.415603989062249)*x83))+(((-0.415603989062249)*x86))+(((-0.415603989062249)*x93))+(((0.0419652385394885)*x80))+(((0.0419652385394885)*x79)));
IkReal x209=((((1.73514642882915e-5)*x81))+(((0.0137159221489464)*x79))+(((0.0137159221489464)*x80))+(((-0.0216893303603644)*r02))+(((-1.0)*x193))+(((-1.0)*x196))+x192+x195+x189+(((0.244396010937751)*x83))+(((0.244396010937751)*x86))+(((0.244396010937751)*x93))+(((-1.73514642882915e-5)*x87)));
IkReal x210=((((-0.0797744116605469)*r02))+(((6.38195293284375e-5)*x81))+(((0.043290989223098)*x79))+(((0.043290989223098)*x80))+(((-1.0)*x203))+x201+(((-6.38195293284375e-5)*x87)));
IkReal x211=((((0.0447120540453595)*x79))+(((-1.0)*x201))+x203+(((2.39006358776141e-5)*x87))+(((-2.39006358776141e-5)*x81))+(((0.0447120540453595)*x80))+(((0.0298757948470176)*r02)));
IkReal x212=((((4.14997958884766e-5)*x87))+(((-0.476395858491101)*x113))+(((-0.000381116686792881)*x100))+((x79*x90))+(((0.0127921843332797)*x80))+x199+(((-1.0)*x202))+(((0.000381116686792881)*x78))+(((0.0127921843332797)*x79))+(((-0.476395858491101)*r02*x85))+(((0.0518747448605958)*r02))+((x80*x90))+(((-4.14997958884766e-5)*x81)));
IkReal x213=((((3.77686289949478e-5)*x81))+(((-0.0120188048898182)*x80))+(((-0.0120188048898182)*x79))+(((-0.456395864891098)*x113))+((x79*x95))+(((-0.0472107862436848)*r02))+(((-1.0)*x199))+(((-1.0)*x190))+(((-3.77686289949478e-5)*x87))+x200+(((-0.456395864891098)*r02*x85))+((x80*x95))+(((-0.000365116691912878)*x100))+(((0.000365116691912878)*x78)));
IkReal x214=((((-0.0135027167444105)*x79))+((x79*x98))+(((-0.203603923909003)*r02*x85))+(((4.40009278531137e-6)*x87))+x199+x190+(((-1.0)*x200))+(((0.000162883139127203)*x78))+(((-0.0135027167444105)*x80))+(((0.00550011598163922)*r02))+((x80*x98))+(((-0.203603923909003)*x113))+(((-0.000162883139127203)*x100))+(((-4.40009278531137e-6)*x81)));
IkReal x215=(((x79*x82))+(((-0.0035640767105492)*r02))+(((0.012729337300949)*x80))+(((-0.0001468831442472)*x100))+(((-1.0)*x199))+(((-0.183603930309)*r02*x85))+x202+(((-0.183603930309)*x113))+((x80*x82))+(((-2.85126136843936e-6)*x87))+(((0.0001468831442472)*x78))+(((0.012729337300949)*x79))+(((2.85126136843936e-6)*x81)));
IkReal gconst0=x208;
IkReal gconst1=x210;
IkReal gconst2=x206;
IkReal gconst3=x212;
IkReal gconst4=x204;
IkReal gconst5=x213;
IkReal gconst6=x208;
IkReal gconst7=x210;
IkReal gconst8=x206;
IkReal gconst9=x212;
IkReal gconst10=x204;
IkReal gconst11=x213;
IkReal gconst12=x214;
IkReal gconst13=x205;
IkReal gconst14=x215;
IkReal gconst15=x207;
IkReal gconst16=x211;
IkReal gconst17=x209;
IkReal gconst18=x214;
IkReal gconst19=x205;
IkReal gconst20=x215;
IkReal gconst21=x207;
IkReal gconst22=x211;
IkReal gconst23=x209;
IkReal x216=((1.0)*gconst21);
IkReal x217=(gconst14*gconst20);
IkReal x218=(gconst13*gconst17);
IkReal x219=(gconst14*gconst4);
IkReal x220=(gconst18*gconst22);
IkReal x221=(gconst20*gconst21);
IkReal x222=(gconst0*gconst17);
IkReal x223=(gconst12*gconst5);
IkReal x224=(gconst21*gconst8);
IkReal x225=((1.0)*gconst9);
IkReal x226=(gconst15*gconst2);
IkReal x227=(gconst16*gconst2);
IkReal x228=(gconst10*gconst18);
IkReal x229=(gconst1*gconst17);
IkReal x230=(gconst2*gconst3);
IkReal x231=(gconst2*gconst4);
IkReal x232=(gconst19*gconst21);
IkReal x233=(gconst19*gconst5);
IkReal x234=(gconst11*gconst6);
IkReal x235=(gconst12*gconst17);
IkReal x236=(gconst8*gconst9);
IkReal x237=(gconst7*gconst9);
IkReal x238=(gconst14*gconst3);
IkReal x239=(gconst14*gconst15);
IkReal x240=(gconst23*gconst6);
IkReal x241=(gconst14*gconst16);
IkReal x242=(gconst10*gconst6);
IkReal x243=(gconst1*gconst5);
IkReal x244=(gconst18*gconst23);
IkReal x245=(gconst20*gconst9);
IkReal x246=(gconst13*gconst5);
IkReal x247=(gconst11*gconst18);
IkReal x248=(gconst21*gconst7);
IkReal x249=(gconst19*gconst9);
IkReal x250=(gconst0*gconst5);
IkReal x251=(gconst22*gconst6);
IkReal x252=((1.0)*x251);
IkReal x253=(gconst2*x249);
IkReal x254=(gconst7*x229);
IkReal x255=((1.0)*x250);
IkReal x256=(gconst23*x255);
op[0]=((((-1.0)*gconst15*x216*x217))+((x239*x244))+((x232*x241))+(((-1.0)*x220*x241))+((x218*x220))+((x221*x235))+(((-1.0)*x235*x244))+(((-1.0)*gconst19*x216*x218)));
op[1]=(((x226*x244))+(((-1.0)*x220*x227))+(((-1.0)*x228*x241))+(((-1.0)*gconst3*x216*x217))+((x220*x246))+(((-1.0)*gconst19*x218*x225))+(((-1.0)*gconst20*x216*x226))+(((-1.0)*x222*x244))+(((-1.0)*gconst15*x217*x225))+(((-1.0)*gconst8*x216*x239))+((x238*x244))+((x219*x232))+(((-1.0)*x241*x252))+((x239*x240))+((x239*x247))+((x220*x229))+((x218*x251))+((x241*x248))+((x241*x249))+((x218*x228))+((x227*x232))+((x224*x235))+((x221*x223))+((x221*x222))+(((-1.0)*x223*x244))+(((-1.0)*x235*x247))+(((-1.0)*x235*x240))+(((-1.0)*x219*x220))+(((-1.0)*gconst7*x216*x218))+((x235*x245))+(((-1.0)*gconst13*x216*x233))+(((-1.0)*gconst19*x216*x229)));
op[2]=(((x246*x251))+((x226*x240))+((x226*x247))+((x234*x239))+(((-1.0)*gconst13*x225*x233))+((x218*x242))+((x230*x244))+(((-1.0)*x216*x254))+((x220*x243))+(((-1.0)*x222*x247))+(((-1.0)*x222*x240))+((x222*x224))+(((-1.0)*x227*x252))+((x229*x251))+((x228*x229))+(((-1.0)*gconst8*x216*x238))+((x237*x241))+((x238*x240))+((x238*x247))+(((-1.0)*gconst8*x216*x226))+(((-1.0)*x244*x255))+((x228*x246))+((x227*x248))+((x227*x249))+(((-1.0)*x241*x242))+((x223*x224))+(((-1.0)*x234*x235))+(((-1.0)*x219*x252))+((x235*x236))+(((-1.0)*gconst20*x216*x230))+(((-1.0)*gconst7*x216*x246))+((x221*x250))+(((-1.0)*gconst3*x217*x225))+(((-1.0)*gconst1*x216*x233))+(((-1.0)*x227*x228))+(((-1.0)*gconst20*x225*x226))+((x223*x245))+(((-1.0)*x223*x247))+(((-1.0)*x223*x240))+((x219*x248))+((x219*x249))+(((-1.0)*gconst8*x225*x239))+((x222*x245))+((x231*x232))+(((-1.0)*x219*x228))+(((-1.0)*gconst7*x218*x225))+(((-1.0)*gconst19*x225*x229))+(((-1.0)*x220*x231)));
op[3]=((((-1.0)*gconst7*x225*x246))+((x234*x238))+(((-1.0)*x223*x234))+((x245*x250))+((x230*x240))+((x230*x247))+(((-1.0)*x240*x255))+(((-1.0)*gconst8*x216*x230))+(((-1.0)*x219*x242))+((x228*x243))+((x226*x234))+(((-1.0)*x225*x254))+((x219*x237))+((x243*x251))+(((-1.0)*gconst1*x225*x233))+((x229*x242))+(((-1.0)*x247*x255))+((x222*x236))+((x231*x248))+((x231*x249))+(((-1.0)*x228*x231))+(((-1.0)*gconst8*x225*x226))+((x227*x237))+(((-1.0)*gconst7*x216*x243))+((x242*x246))+(((-1.0)*gconst8*x225*x238))+(((-1.0)*x231*x252))+(((-1.0)*x222*x234))+((x223*x236))+(((-1.0)*x227*x242))+((x224*x250))+(((-1.0)*gconst20*x225*x230)));
op[4]=((((-1.0)*gconst7*x225*x243))+(((-1.0)*x231*x242))+((x230*x234))+((x242*x243))+((x236*x250))+(((-1.0)*x234*x255))+(((-1.0)*gconst8*x225*x230))+((x231*x237)));
polyroots4(op,zeror,numroots);
IkReal j2array[4], cj2array[4], sj2array[4], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[4]={true,true,true,true};
_nj2 = 4;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=((((0.999999680000154)*r00*sj0))+(((-0.999999680000154)*cj0*r01))+(((-0.000799999744000123)*r02)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x257=px*px;
IkReal x258=pz*pz;
IkReal x259=py*py;
IkReal x260=(cj4*sj2);
IkReal x261=((0.008355648)*cj2);
IkReal x262=(pz*r02);
IkReal x263=(py*sj0);
IkReal x264=(cj4*pz);
IkReal x265=(r01*sj2);
IkReal x266=(r00*sj2);
IkReal x267=((0.00047348672)*cj2);
IkReal x268=(r01*sj0);
IkReal x269=(cj0*r00);
IkReal x270=(cj2*cj4);
IkReal x271=((0.0004177824)*cj2);
IkReal x272=(cj0*py);
IkReal x273=((2.98480544486241e-5)*cj4);
IkReal x274=(cj0*px);
IkReal x275=(cj2*r00);
IkReal x276=(px*sj0);
IkReal x277=((0.002785216)*cj2);
IkReal x278=(py*r01);
IkReal x279=(r02*sj2);
IkReal x280=((0.00050133888)*cj2);
IkReal x281=((1.49240272243121e-5)*cj4);
IkReal x282=(cj2*r02);
IkReal x283=((0.00932752)*cj4);
IkReal x284=((0.00044563456)*cj2);
IkReal x285=(cj0*cj2*r01);
IkReal x286=(x274*x283);
IkReal x287=(x263*x283);
IkReal x288=((0.031632096)*sj2*x262);
IkReal x289=((0.031632096)*py*x265);
IkReal x290=((0.031632096)*px*x266);
IkReal x291=(x261*x278);
IkReal x292=(x261*x262);
IkReal x293=(px*r00*x261);
IkReal x294=((0.010544032)*py*x265);
IkReal x295=((0.010544032)*sj2*x262);
IkReal x296=((0.010544032)*px*x266);
IkReal x297=((0.002785216)*px*x275);
IkReal x298=(x262*x277);
IkReal x299=(x277*x278);
IkReal x300=((0.104904)*x259*x270);
IkReal x301=((0.104904)*x258*x270);
IkReal x302=((0.102552)*x258*x260);
IkReal x303=((0.102552)*x259*x260);
IkReal x304=((0.104904)*x257*x270);
IkReal x305=((0.102552)*x257*x260);
IkReal x306=((0.034184)*x258*x260);
IkReal x307=((0.034184)*x257*x260);
IkReal x308=((0.034968)*x257*x270);
IkReal x309=((0.034968)*x258*x270);
IkReal x310=((0.034184)*x259*x260);
IkReal x311=((0.034968)*x259*x270);
IkReal x312=(x287+x286);
IkReal x313=(x294+x295+x296);
IkReal x314=(x290+x289+x288);
IkReal x315=(x304+x305+x302+x303+x300+x301+x291+x292+x293);
IkReal x316=(x308+x309+x306+x307+x311+x310+x298+x299+x297);
IkReal x317=((((1.80491462242741e-5)*x260*x272))+(((0.00347952944655076)*x279))+(((-0.0186550340303901)*x264))+(((-2.7836235572406e-6)*cj0*x265))+(((-1.0)*x276*x281))+(((-1.84630980918096e-5)*x270*x276))+(((7.35296788705065e-7)*x285))+(((1.84630980918096e-5)*x270*x272))+(((-0.000919120985881332)*x282))+(((-7.35296788705065e-7)*sj0*x275))+(((-1.80491462242741e-5)*x260*x276))+((x272*x281))+(((-0.0230788726147619)*cj2*x264))+(((-0.0225614327803427)*pz*x260))+(((2.7836235572406e-6)*sj0*x266)));
op[0]=((((0.00168704512)*cj0*x266))+(((-0.01093888)*x260*x263))+(((-0.01093888)*x260*x274))+(((-0.000875603568)*x270))+(((-0.000880267184)*x260))+(((0.00168704512)*sj0*x265))+(((-0.0014924032)*cj4))+x313+(((-1.0)*x312))+(((-1.0)*x316))+(((-0.01118976)*x270*x274))+(((-1.0)*x268*x284))+(((-1.0)*x269*x284))+(((-0.01118976)*x263*x270)));
op[1]=x317;
op[2]=((((-0.002742205104)*x270))+(((0.0015816048)*cj0*x266))+(((-1.0)*x269*x271))+(((-0.002753608752)*x260))+x314+(((-1.0)*x315))+(((-1.0)*x312))+(((-0.0104904)*x263*x270))+(((-1.0)*x268*x271))+(((-0.0104904)*x270*x274))+(((-0.0045704848)*cj4))+(((-0.0102552)*x260*x274))+(((-0.0102552)*x260*x263))+(((0.0015816048)*sj0*x265)));
op[3]=(((x272*x273))+(((-1.0)*x273*x276))+(((-1.47059357741013e-6)*sj0*x275))+(((-0.0461577452295239)*cj2*x264))+(((1.47059357741013e-6)*x285))+(((-0.00183824197176266)*x282))+(((-5.56724711448121e-6)*cj0*x265))+(((-3.60982924485483e-5)*x260*x276))+(((3.60982924485483e-5)*x260*x272))+(((0.00695905889310151)*x279))+(((-0.0373100680607801)*x264))+(((5.56724711448121e-6)*sj0*x266))+(((-3.69261961836191e-5)*x270*x276))+(((3.69261961836191e-5)*x270*x272))+(((-0.0451228655606853)*pz*x260)));
op[4]=(((x268*x280))+((x269*x280))+(((0.01258848)*x270*x274))+(((-0.00466376)*cj4))+(((-0.002857599504)*x270))+x314+x312+(((-1.0)*x315))+(((-0.002866415952)*x260))+(((0.01258848)*x263*x270))+(((-0.00189792576)*sj0*x265))+(((0.01230624)*x260*x263))+(((0.01230624)*x260*x274))+(((-0.00189792576)*cj0*x266)));
op[5]=x317;
op[6]=((((0.01162256)*x260*x274))+((x267*x268))+((x267*x269))+(((0.01188912)*x263*x270))+(((0.01162256)*x260*x263))+(((0.01188912)*x270*x274))+x313+x312+(((-1.0)*x316))+(((-0.00179248544)*cj0*x266))+(((-0.000993074384)*x260))+(((-0.00179248544)*sj0*x265))+(((-0.0015856784)*cj4))+(((-0.000990997968)*x270)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

j1evalpoly[0]=(((htj1*(((((-2.62605995966095e-5)*px*sj0*(cj2*cj2)))+(((-1.68704458014582e-5)*cj2*px*sj0))+(((-4.45634417397009e-6)*px*sj0*sj2))+(((-2.62605995966095e-5)*px*sj0*(sj2*sj2)))+(((0.005570432)*cj0*cj2*px))+(((1.68704458014582e-5)*cj0*cj2*py))+(((-0.0210880572518228)*cj2*pz))+(((0.005570432)*cj2*py*sj0))+(((-0.021088064)*cj0*px*sj2))+(((-0.0328257494957618)*pz*(sj2*sj2)))+(((-0.0328257494957618)*pz*(cj2*cj2)))+(((2.62605995966095e-5)*cj0*py*(sj2*sj2)))+(((0.00010544032)*sj2))+(((-0.021088064)*py*sj0*sj2))+(((-0.00557043021746262)*pz*sj2))+(((2.62605995966095e-5)*cj0*py*(cj2*cj2)))+(((-2.785216e-5)*cj2))+(((4.45634417397009e-6)*cj0*py*sj2))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((2.22817208698505e-6)*cj0*cj2*py))+(((-0.049736)*(cj2*cj2)*(pz*pz)))+(((0.0105440286259114)*pz*sj2))+(((-0.049736)*(px*px)*(sj2*sj2)))+(((-2.22817208698505e-6)*cj2*px*sj0))+(((-0.049736)*(pz*pz)*(sj2*sj2)))+(((-0.049736)*(py*py)*(sj2*sj2)))+(((-0.01591552)*py*sj0*(cj2*cj2)))+(((-8.4352229007291e-6)*cj0*py*sj2))+(((-0.010544032)*cj2*py*sj0))+(((-0.010544032)*cj0*cj2*px))+(((8.4352229007291e-6)*px*sj0*sj2))+(((-0.01591552)*cj0*px*(cj2*cj2)))+(((-0.00278521510873131)*cj2*pz))+(((-0.00044563456)*sj2))+(((-0.00168704512)*cj2))+(((-0.01591552)*cj0*px*(sj2*sj2)))+(((-0.01591552)*py*sj0*(sj2*sj2)))+(((-0.049736)*(cj2*cj2)*(px*px)))+(((-0.002785216)*cj0*px*sj2))+(((-0.002785216)*py*sj0*sj2))+(((-0.001252650896)*(cj2*cj2)))+(((-0.001252650896)*(sj2*sj2)))+(((-0.049736)*(cj2*cj2)*(py*py)))))))+(((-0.049736)*(cj2*cj2)*(pz*pz)))+(((-0.049736)*(px*px)*(sj2*sj2)))+(((0.01691024)*cj0*px*(cj2*cj2)))+(((-0.049736)*(pz*pz)*(sj2*sj2)))+(((0.002785216)*cj0*px*sj2))+(((htj1*htj1*htj1*htj1*htj1)*(((((-2.62605995966095e-5)*px*sj0*(cj2*cj2)))+(((-1.68704458014582e-5)*cj2*px*sj0))+(((-4.45634417397009e-6)*px*sj0*sj2))+(((-2.62605995966095e-5)*px*sj0*(sj2*sj2)))+(((0.005570432)*cj0*cj2*px))+(((1.68704458014582e-5)*cj0*cj2*py))+(((-0.0210880572518228)*cj2*pz))+(((0.005570432)*cj2*py*sj0))+(((-0.021088064)*cj0*px*sj2))+(((-0.0328257494957618)*pz*(sj2*sj2)))+(((-0.0328257494957618)*pz*(cj2*cj2)))+(((2.62605995966095e-5)*cj0*py*(sj2*sj2)))+(((0.00010544032)*sj2))+(((-0.021088064)*py*sj0*sj2))+(((-0.00557043021746262)*pz*sj2))+(((2.62605995966095e-5)*cj0*py*(cj2*cj2)))+(((-2.785216e-5)*cj2))+(((4.45634417397009e-6)*cj0*py*sj2))))))+(((htj1*htj1)*(((((-0.149208)*(cj2*cj2)*(px*px)))+(((-0.001392608)*sj2))+(((-0.005272016)*cj2))+(((0.002785216)*cj0*px*sj2))+(((0.00278521510873131)*cj2*pz))+(((8.4352229007291e-6)*cj0*py*sj2))+(((0.010544032)*cj0*cj2*px))+(((-0.004086210288)*(sj2*sj2)))+(((-0.0105440286259114)*pz*sj2))+(((0.01790496)*py*sj0*(cj2*cj2)))+(((-0.149208)*(pz*pz)*(sj2*sj2)))+(((0.01790496)*cj0*px*(sj2*sj2)))+(((-0.149208)*(cj2*cj2)*(py*py)))+(((-8.4352229007291e-6)*px*sj0*sj2))+(((-0.149208)*(py*py)*(sj2*sj2)))+(((-0.149208)*(cj2*cj2)*(pz*pz)))+(((0.01790496)*py*sj0*(sj2*sj2)))+(((0.01790496)*cj0*px*(cj2*cj2)))+(((-0.004086210288)*(cj2*cj2)))+(((2.22817208698505e-6)*cj2*px*sj0))+(((-2.22817208698505e-6)*cj0*cj2*py))+(((-0.149208)*(px*px)*(sj2*sj2)))+(((0.010544032)*cj2*py*sj0))+(((0.002785216)*py*sj0*sj2))))))+(((-0.049736)*(py*py)*(sj2*sj2)))+(((0.00278521510873131)*cj2*pz))+(((8.4352229007291e-6)*cj0*py*sj2))+(((0.010544032)*cj0*cj2*px))+(((-0.0105440286259114)*pz*sj2))+(((0.01691024)*py*sj0*(sj2*sj2)))+(((-0.00047348672)*sj2))+(((-8.4352229007291e-6)*px*sj0*sj2))+(((0.01691024)*py*sj0*(cj2*cj2)))+(((htj1*htj1*htj1*htj1)*(((((2.22817208698505e-6)*cj0*cj2*py))+(((0.0105440286259114)*pz*sj2))+(((-0.149208)*(cj2*cj2)*(px*px)))+(((-0.00136475584)*sj2))+(((-2.22817208698505e-6)*cj2*px*sj0))+(((-0.00516657568)*cj2))+(((-8.4352229007291e-6)*cj0*py*sj2))+(((-0.010544032)*cj2*py*sj0))+(((-0.0149208)*cj0*px*(cj2*cj2)))+(((-0.010544032)*cj0*cj2*px))+(((8.4352229007291e-6)*px*sj0*sj2))+(((-0.149208)*(pz*pz)*(sj2*sj2)))+(((-0.00278521510873131)*cj2*pz))+(((-0.149208)*(cj2*cj2)*(py*py)))+(((-0.0149208)*py*sj0*(cj2*cj2)))+(((-0.149208)*(py*py)*(sj2*sj2)))+(((-0.003922081488)*(sj2*sj2)))+(((-0.0149208)*py*sj0*(sj2*sj2)))+(((-0.149208)*(cj2*cj2)*(pz*pz)))+(((-0.002785216)*cj0*px*sj2))+(((-0.002785216)*py*sj0*sj2))+(((-0.003922081488)*(cj2*cj2)))+(((-0.149208)*(px*px)*(sj2*sj2)))+(((-0.0149208)*cj0*px*(sj2*sj2)))))))+(((-0.049736)*(cj2*cj2)*(px*px)))+(((0.01691024)*cj0*px*(sj2*sj2)))+(((2.22817208698505e-6)*cj2*px*sj0))+(((-0.001416779696)*(sj2*sj2)))+(((-2.22817208698505e-6)*cj0*cj2*py))+(((-0.001416779696)*(cj2*cj2)))+(((htj1*htj1*htj1)*(((((-5.570432e-5)*cj2))+(((0.011140864)*cj0*cj2*px))+(((-0.0111408604349252)*pz*sj2))+(((-0.0656514989915237)*pz*(sj2*sj2)))+(((5.25211991932189e-5)*cj0*py*(sj2*sj2)))+(((0.011140864)*cj2*py*sj0))+(((-0.042176128)*cj0*px*sj2))+(((-0.0421761145036455)*cj2*pz))+(((-5.25211991932189e-5)*px*sj0*(cj2*cj2)))+(((5.25211991932189e-5)*cj0*py*(cj2*cj2)))+(((-0.0656514989915237)*pz*(cj2*cj2)))+(((-5.25211991932189e-5)*px*sj0*(sj2*sj2)))+(((-8.91268834794018e-6)*px*sj0*sj2))+(((0.00021088064)*sj2))+(((-3.37408916029164e-5)*cj2*px*sj0))+(((8.91268834794018e-6)*cj0*py*sj2))+(((3.37408916029164e-5)*cj0*cj2*py))+(((-0.042176128)*py*sj0*sj2))))))+(((-0.00179248544)*cj2))+(((0.010544032)*cj2*py*sj0))+(((-0.049736)*(cj2*cj2)*(py*py)))+(((0.002785216)*py*sj0*sj2)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3eval[2];
j3eval[0]=cj4;
j3eval[1]=IKsign(cj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x318=((0.00353868312047666)*px);
IkReal x319=((7.80119028470323)*py);
IkReal x320=(cj2*sj1);
IkReal x321=(px*sj2);
IkReal x322=(cj0*sj1);
IkReal x323=((4.42335390059582)*pz);
IkReal x324=(cj1*sj0);
IkReal x325=(sj1*sj2);
IkReal x326=((4.42335531606884)*py);
IkReal x327=(cj0*cj1);
IkReal x328=(cj1*sj2);
IkReal x329=((7.80118778832354)*pz);
IkReal x330=(cj1*cj2);
IkReal x331=((7.80119028470323)*px);
IkReal x332=((0.00353868312047666)*py);
IkReal x333=((0.00624095023065883)*px);
IkReal x334=((0.00624095023065883)*py);
IkReal x335=((4.42335531606884)*px);
IkReal x336=(cj2*x324);
IkReal x337=(sj2*x332);
if( IKabs(((-0.250442335531607)+((x325*x329))+(((-4.42335531606884)*x321*x322))+(((-0.729853627151359)*cj2))+(((-1.0)*x333*x336))+((cj0*x320*x332))+((cj2*x327*x335))+((cj2*x327*x334))+(((-1.0)*x329*x330))+(((-7.80119028470323)*x321*x327))+(((0.0221167765803442)*x325))+(((-1.0)*x323*x328))+(((-1.0)*x320*x323))+(((-1.0)*sj2*x322*x334))+(((-1.0)*cj0*x320*x331))+((x327*x337))+(((-1.0)*sj2*x319*x324))+(((-1.0)*sj2*x318*x324))+(((1.28719639697603)*sj2))+((x326*x336))+(((-1.0)*sj0*x318*x320))+(((0.0390059514235162)*x320))+(((0.0390059514235162)*x328))+(((-0.0221167765803442)*x330))+(((-1.0)*sj0*x325*x326))+(((-1.0)*sj0*x319*x320))+(((0.00624095023065883)*sj0*sj1*x321)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.95078011902847)+(((-1.28719639697603)*cj2))+(((-0.729853627151359)*sj2))+((cj0*x320*x335))+((cj0*x320*x334))+((sj2*x324*x326))+((cj2*x327*x331))+((x318*x336))+((sj0*x320*x326))+(((-7.80119028470323)*x321*x322))+((x319*x336))+((sj2*x327*x334))+(((-1.0)*cj2*x327*x332))+(((-0.0390059514235162)*x330))+(((-1.0)*x323*x325))+(((-1.0)*x320*x329))+(((-0.0221167765803442)*x328))+(((-0.0221167765803442)*x320))+(((-0.00624095023065883)*x321*x324))+((x323*x330))+(((-1.0)*sj0*x318*x325))+((x322*x337))+(((-1.0)*x328*x329))+(((0.0390059514235162)*x325))+(((4.42335531606884)*x321*x327))+(((-1.0)*sj0*x320*x333))+(((-1.0)*sj0*x319*x325)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.250442335531607)+((x325*x329))+(((-4.42335531606884)*x321*x322))+(((-0.729853627151359)*cj2))+(((-1.0)*x333*x336))+((cj0*x320*x332))+((cj2*x327*x335))+((cj2*x327*x334))+(((-1.0)*x329*x330))+(((-7.80119028470323)*x321*x327))+(((0.0221167765803442)*x325))+(((-1.0)*x323*x328))+(((-1.0)*x320*x323))+(((-1.0)*sj2*x322*x334))+(((-1.0)*cj0*x320*x331))+((x327*x337))+(((-1.0)*sj2*x319*x324))+(((-1.0)*sj2*x318*x324))+(((1.28719639697603)*sj2))+((x326*x336))+(((-1.0)*sj0*x318*x320))+(((0.0390059514235162)*x320))+(((0.0390059514235162)*x328))+(((-0.0221167765803442)*x330))+(((-1.0)*sj0*x325*x326))+(((-1.0)*sj0*x319*x320))+(((0.00624095023065883)*sj0*sj1*x321))))+IKsqr(((-0.95078011902847)+(((-1.28719639697603)*cj2))+(((-0.729853627151359)*sj2))+((cj0*x320*x335))+((cj0*x320*x334))+((sj2*x324*x326))+((cj2*x327*x331))+((x318*x336))+((sj0*x320*x326))+(((-7.80119028470323)*x321*x322))+((x319*x336))+((sj2*x327*x334))+(((-1.0)*cj2*x327*x332))+(((-0.0390059514235162)*x330))+(((-1.0)*x323*x325))+(((-1.0)*x320*x329))+(((-0.0221167765803442)*x328))+(((-0.0221167765803442)*x320))+(((-0.00624095023065883)*x321*x324))+((x323*x330))+(((-1.0)*sj0*x318*x325))+((x322*x337))+(((-1.0)*x328*x329))+(((0.0390059514235162)*x325))+(((4.42335531606884)*x321*x327))+(((-1.0)*sj0*x320*x333))+(((-1.0)*sj0*x319*x325))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.250442335531607)+((x325*x329))+(((-4.42335531606884)*x321*x322))+(((-0.729853627151359)*cj2))+(((-1.0)*x333*x336))+((cj0*x320*x332))+((cj2*x327*x335))+((cj2*x327*x334))+(((-1.0)*x329*x330))+(((-7.80119028470323)*x321*x327))+(((0.0221167765803442)*x325))+(((-1.0)*x323*x328))+(((-1.0)*x320*x323))+(((-1.0)*sj2*x322*x334))+(((-1.0)*cj0*x320*x331))+((x327*x337))+(((-1.0)*sj2*x319*x324))+(((-1.0)*sj2*x318*x324))+(((1.28719639697603)*sj2))+((x326*x336))+(((-1.0)*sj0*x318*x320))+(((0.0390059514235162)*x320))+(((0.0390059514235162)*x328))+(((-0.0221167765803442)*x330))+(((-1.0)*sj0*x325*x326))+(((-1.0)*sj0*x319*x320))+(((0.00624095023065883)*sj0*sj1*x321))), ((-0.95078011902847)+(((-1.28719639697603)*cj2))+(((-0.729853627151359)*sj2))+((cj0*x320*x335))+((cj0*x320*x334))+((sj2*x324*x326))+((cj2*x327*x331))+((x318*x336))+((sj0*x320*x326))+(((-7.80119028470323)*x321*x322))+((x319*x336))+((sj2*x327*x334))+(((-1.0)*cj2*x327*x332))+(((-0.0390059514235162)*x330))+(((-1.0)*x323*x325))+(((-1.0)*x320*x329))+(((-0.0221167765803442)*x328))+(((-0.0221167765803442)*x320))+(((-0.00624095023065883)*x321*x324))+((x323*x330))+(((-1.0)*sj0*x318*x325))+((x322*x337))+(((-1.0)*x328*x329))+(((0.0390059514235162)*x325))+(((4.42335531606884)*x321*x327))+(((-1.0)*sj0*x320*x333))+(((-1.0)*sj0*x319*x325))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x338=IKsin(j3);
IkReal x339=IKcos(j3);
IkReal x340=((0.106)*sj2);
IkReal x341=((0.028)*cj2);
IkReal x342=((0.028)*sj2);
IkReal x343=((0.106)*cj2);
IkReal x344=py*py;
IkReal x345=pz*pz;
IkReal x346=px*px;
IkReal x347=(r00*sj0);
IkReal x348=(pz*sj1);
IkReal x349=((0.000799999744000123)*r02);
IkReal x350=(py*sj1);
IkReal x351=((0.000799999744000123)*cj0);
IkReal x352=(cj0*r01);
IkReal x353=(cj1*pz);
IkReal x354=(cj1*r02);
IkReal x355=(py*sj0);
IkReal x356=(px*r01);
IkReal x357=((0.00499999840000077)*sj1);
IkReal x358=(cj0*px);
IkReal x359=(cj0*py);
IkReal x360=(cj1*py);
IkReal x361=(px*pz);
IkReal x362=(r02*sj0);
IkReal x363=(px*sj1);
IkReal x364=((0.00164999947200025)*cj1);
IkReal x365=((0.999999680000154)*r00);
IkReal x366=(py*r00);
IkReal x367=(px*sj0);
IkReal x368=((0.33)*cj1);
IkReal x369=((7.99999744000123e-6)*r02);
IkReal x370=((1.0)*cj1);
IkReal x371=((0.00499999840000077)*cj1);
IkReal x372=((0.000263999915520041)*sj0);
IkReal x373=(cj0*r02);
IkReal x374=(pz*r01);
IkReal x375=((0.000263999915520041)*cj0);
IkReal x376=((0.006228)*x338);
IkReal x377=((0.023644)*x339);
IkReal x378=((0.999999680000154)*x344);
IkReal x379=((0.097)*x339);
IkReal x380=((0.999999680000154)*x345);
IkReal x381=((0.000799999744000123)*r01*sj0);
IkReal x382=(cj2*x338);
IkReal x383=(sj2*x338);
IkReal x384=((0.999999680000154)*x346);
IkReal x385=((0.055)*x339);
IkReal x386=((0.097)*x382);
IkReal x387=((0.055)*x383);
IkReal x388=(sj2*x379);
IkReal x389=(cj2*x385);
IkReal x390=((0.097)*x383);
IkReal x391=((0.055)*x382);
IkReal x392=(cj2*x379);
IkReal x393=(sj2*x385);
IkReal x394=(x377+x376);
IkReal x395=(x389+x341);
IkReal x396=(x386+x387+x388+x340);
IkReal x397=(x342+x343+x391+x393+x392);
evalcond[0]=((((-1.0)*x395))+(((0.000799999744000123)*cj1*x367))+(((0.999999680000154)*x353))+x396+((sj0*x350))+((sj1*x358))+(((-0.005)*sj1))+(((-1.0)*x351*x360)));
evalcond[1]=((0.165)+(((0.005)*cj1))+(((-1.0)*x390))+(((-1.0)*x355*x370))+(((-1.0)*x358*x370))+x397+(((0.000799999744000123)*sj0*x363))+(((0.999999680000154)*x348))+(((-1.0)*x350*x351)));
evalcond[2]=((-0.002796)+(((-1.0)*x363*x372))+((x358*x368))+((x350*x375))+((x355*x368))+x394+(((-0.329999894400051)*x348))+(((0.01)*x358))+(((0.01)*x355))+(((-0.00165)*cj1))+(((-1.0)*x345))+(((-1.0)*x346))+(((-1.0)*x344)));
evalcond[3]=((((3.99999872000061e-6)*r02*sj1))+(((-1.0)*x395))+((x350*x365))+(((-1.0)*sj1*x349*x358))+((x348*x381))+(((-1.0)*x352*x353))+((x352*x357))+(((-1.0)*sj0*x349*x350))+x396+((x354*x359))+((x347*x353))+(((-0.999999680000154)*sj1*x356))+(((-1.0)*x347*x357))+((r00*x348*x351))+(((-1.0)*x354*x367)));
evalcond[4]=((((-1.0)*x347*x371))+(((-1.0)*x397))+(((0.00013199995776002)*r02))+(((-1.0)*x350*x373))+(((3.99999872000061e-6)*x354))+((r00*x351*x353))+(((-1.0)*cj1*x349*x358))+(((-1.0)*cj1*x349*x355))+((x352*x371))+x390+(((0.164999947200025)*x352))+((x348*x352))+(((-0.999999680000154)*cj1*x356))+(((-1.0)*x347*x348))+((x360*x365))+(((-0.164999947200025)*x347))+((x362*x363))+((x353*x381)));
evalcond[5]=((-0.024454)+((x358*x369))+(((-1.0)*x394))+(((0.33)*x350*x373))+(((-1.3199995776002e-6)*x354))+(((-0.00999999680000153)*x366))+(((-1.0)*r00*x353*x375))+(((-0.329999894400051)*r00*x360))+(((-1.0)*x352*x364))+((x355*x369))+(((-1.0)*x347*x384))+((x347*x378))+((x352*x378))+((x347*x364))+((x345*x349))+(((1.99999936000031)*pz*r02*x359))+(((-1.0)*x344*x349))+(((-1.99999936000031)*x361*x362))+(((-0.33)*x362*x363))+(((-1.99999936000031)*x355*x356))+(((0.00159999948800025)*r00*x361))+(((-1.0)*x352*x384))+(((-1.0)*x352*x380))+(((-1.0)*x346*x349))+(((0.33)*x347*x348))+(((-7.99999744000123e-6)*sj0*x374))+(((0.00999999680000153)*x356))+(((0.00159999948800025)*py*x374))+((x347*x380))+(((0.0272499912800042)*x347))+(((-2.17999930240033e-5)*r02))+(((-1.0)*r01*x353*x372))+(((-7.99999744000123e-6)*cj0*pz*r00))+(((1.99999936000031)*x358*x366))+(((-0.0272499912800042)*x352))+(((0.000263999915520041)*x354*x355))+(((0.000263999915520041)*x354*x358))+(((0.329999894400051)*cj1*x356))+(((-0.33)*x348*x352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x398=((0.00353868312047666)*px);
IkReal x399=((7.80119028470323)*py);
IkReal x400=(cj2*sj1);
IkReal x401=(px*sj2);
IkReal x402=(cj0*sj1);
IkReal x403=((4.42335390059582)*pz);
IkReal x404=(cj1*sj0);
IkReal x405=(sj1*sj2);
IkReal x406=((4.42335531606884)*py);
IkReal x407=(cj0*cj1);
IkReal x408=(cj1*sj2);
IkReal x409=((7.80118778832354)*pz);
IkReal x410=(cj1*cj2);
IkReal x411=((7.80119028470323)*px);
IkReal x412=((0.00353868312047666)*py);
IkReal x413=((0.00624095023065883)*px);
IkReal x414=((0.00624095023065883)*py);
IkReal x415=((4.42335531606884)*px);
IkReal x416=(cj2*x404);
IkReal x417=(sj2*x412);
if( IKabs(((-0.250442335531607)+((x407*x417))+((x405*x409))+(((-0.729853627151359)*cj2))+(((0.00624095023065883)*sj0*sj1*x401))+(((0.0390059514235162)*x400))+(((0.0390059514235162)*x408))+(((-7.80119028470323)*x401*x407))+(((-1.0)*x403*x408))+((x406*x416))+(((-1.0)*sj0*x399*x400))+(((-4.42335531606884)*x401*x402))+((cj2*x407*x414))+((cj2*x407*x415))+(((-1.0)*x400*x403))+(((-1.0)*sj2*x402*x414))+(((-1.0)*sj0*x405*x406))+(((-1.0)*sj2*x399*x404))+(((-0.0221167765803442)*x410))+(((-1.0)*sj0*x398*x400))+(((-1.0)*sj2*x398*x404))+(((0.0221167765803442)*x405))+((cj0*x400*x412))+(((-1.0)*x413*x416))+(((1.28719639697603)*sj2))+(((-1.0)*cj0*x400*x411))+(((-1.0)*x409*x410)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.95078011902847)+(((4.42335531606884)*x401*x407))+(((-1.28719639697603)*cj2))+((sj0*x400*x406))+(((-0.0390059514235162)*x410))+(((-0.729853627151359)*sj2))+(((0.0390059514235162)*x405))+(((-7.80119028470323)*x401*x402))+(((-1.0)*sj0*x400*x413))+(((-1.0)*cj2*x407*x412))+(((-1.0)*x403*x405))+(((-1.0)*sj0*x399*x405))+((cj2*x407*x411))+(((-1.0)*x400*x409))+(((-0.00624095023065883)*x401*x404))+(((-1.0)*sj0*x398*x405))+(((-0.0221167765803442)*x408))+(((-0.0221167765803442)*x400))+((x398*x416))+((cj0*x400*x415))+((cj0*x400*x414))+((sj2*x404*x406))+((x399*x416))+((x403*x410))+((x402*x417))+((sj2*x407*x414))+(((-1.0)*x408*x409)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.250442335531607)+((x407*x417))+((x405*x409))+(((-0.729853627151359)*cj2))+(((0.00624095023065883)*sj0*sj1*x401))+(((0.0390059514235162)*x400))+(((0.0390059514235162)*x408))+(((-7.80119028470323)*x401*x407))+(((-1.0)*x403*x408))+((x406*x416))+(((-1.0)*sj0*x399*x400))+(((-4.42335531606884)*x401*x402))+((cj2*x407*x414))+((cj2*x407*x415))+(((-1.0)*x400*x403))+(((-1.0)*sj2*x402*x414))+(((-1.0)*sj0*x405*x406))+(((-1.0)*sj2*x399*x404))+(((-0.0221167765803442)*x410))+(((-1.0)*sj0*x398*x400))+(((-1.0)*sj2*x398*x404))+(((0.0221167765803442)*x405))+((cj0*x400*x412))+(((-1.0)*x413*x416))+(((1.28719639697603)*sj2))+(((-1.0)*cj0*x400*x411))+(((-1.0)*x409*x410))))+IKsqr(((-0.95078011902847)+(((4.42335531606884)*x401*x407))+(((-1.28719639697603)*cj2))+((sj0*x400*x406))+(((-0.0390059514235162)*x410))+(((-0.729853627151359)*sj2))+(((0.0390059514235162)*x405))+(((-7.80119028470323)*x401*x402))+(((-1.0)*sj0*x400*x413))+(((-1.0)*cj2*x407*x412))+(((-1.0)*x403*x405))+(((-1.0)*sj0*x399*x405))+((cj2*x407*x411))+(((-1.0)*x400*x409))+(((-0.00624095023065883)*x401*x404))+(((-1.0)*sj0*x398*x405))+(((-0.0221167765803442)*x408))+(((-0.0221167765803442)*x400))+((x398*x416))+((cj0*x400*x415))+((cj0*x400*x414))+((sj2*x404*x406))+((x399*x416))+((x403*x410))+((x402*x417))+((sj2*x407*x414))+(((-1.0)*x408*x409))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.250442335531607)+((x407*x417))+((x405*x409))+(((-0.729853627151359)*cj2))+(((0.00624095023065883)*sj0*sj1*x401))+(((0.0390059514235162)*x400))+(((0.0390059514235162)*x408))+(((-7.80119028470323)*x401*x407))+(((-1.0)*x403*x408))+((x406*x416))+(((-1.0)*sj0*x399*x400))+(((-4.42335531606884)*x401*x402))+((cj2*x407*x414))+((cj2*x407*x415))+(((-1.0)*x400*x403))+(((-1.0)*sj2*x402*x414))+(((-1.0)*sj0*x405*x406))+(((-1.0)*sj2*x399*x404))+(((-0.0221167765803442)*x410))+(((-1.0)*sj0*x398*x400))+(((-1.0)*sj2*x398*x404))+(((0.0221167765803442)*x405))+((cj0*x400*x412))+(((-1.0)*x413*x416))+(((1.28719639697603)*sj2))+(((-1.0)*cj0*x400*x411))+(((-1.0)*x409*x410))), ((-0.95078011902847)+(((4.42335531606884)*x401*x407))+(((-1.28719639697603)*cj2))+((sj0*x400*x406))+(((-0.0390059514235162)*x410))+(((-0.729853627151359)*sj2))+(((0.0390059514235162)*x405))+(((-7.80119028470323)*x401*x402))+(((-1.0)*sj0*x400*x413))+(((-1.0)*cj2*x407*x412))+(((-1.0)*x403*x405))+(((-1.0)*sj0*x399*x405))+((cj2*x407*x411))+(((-1.0)*x400*x409))+(((-0.00624095023065883)*x401*x404))+(((-1.0)*sj0*x398*x405))+(((-0.0221167765803442)*x408))+(((-0.0221167765803442)*x400))+((x398*x416))+((cj0*x400*x415))+((cj0*x400*x414))+((sj2*x404*x406))+((x399*x416))+((x403*x410))+((x402*x417))+((sj2*x407*x414))+(((-1.0)*x408*x409))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x418=IKsin(j3);
IkReal x419=IKcos(j3);
IkReal x420=((0.028)*cj2);
IkReal x421=((0.106)*sj2);
IkReal x422=((0.028)*sj2);
IkReal x423=((0.106)*cj2);
IkReal x424=py*py;
IkReal x425=pz*pz;
IkReal x426=px*px;
IkReal x427=(r00*sj0);
IkReal x428=(pz*sj1);
IkReal x429=((0.000799999744000123)*r02);
IkReal x430=(py*sj1);
IkReal x431=((0.000799999744000123)*cj0);
IkReal x432=(cj0*r01);
IkReal x433=(cj1*pz);
IkReal x434=(cj1*r02);
IkReal x435=(py*sj0);
IkReal x436=(px*r01);
IkReal x437=((0.00499999840000077)*sj1);
IkReal x438=(cj0*px);
IkReal x439=(cj0*py);
IkReal x440=(cj1*py);
IkReal x441=(px*pz);
IkReal x442=(r02*sj0);
IkReal x443=(px*sj1);
IkReal x444=((0.00164999947200025)*cj1);
IkReal x445=((0.999999680000154)*r00);
IkReal x446=(py*r00);
IkReal x447=(px*sj0);
IkReal x448=((0.33)*cj1);
IkReal x449=((7.99999744000123e-6)*r02);
IkReal x450=((1.0)*cj1);
IkReal x451=((0.00499999840000077)*cj1);
IkReal x452=((0.000263999915520041)*sj0);
IkReal x453=(cj0*r02);
IkReal x454=(pz*r01);
IkReal x455=((0.000263999915520041)*cj0);
IkReal x456=((0.006228)*x418);
IkReal x457=((0.023644)*x419);
IkReal x458=((0.999999680000154)*x424);
IkReal x459=((0.097)*x419);
IkReal x460=((0.999999680000154)*x425);
IkReal x461=((0.000799999744000123)*r01*sj0);
IkReal x462=(cj2*x418);
IkReal x463=(sj2*x418);
IkReal x464=((0.999999680000154)*x426);
IkReal x465=((0.055)*x419);
IkReal x466=(cj2*x465);
IkReal x467=((0.097)*x462);
IkReal x468=((0.055)*x463);
IkReal x469=(sj2*x459);
IkReal x470=((0.055)*x462);
IkReal x471=(cj2*x459);
IkReal x472=(sj2*x465);
IkReal x473=((0.097)*x463);
IkReal x474=(x420+x466);
IkReal x475=(x456+x457);
IkReal x476=(x421+x469+x468+x467);
IkReal x477=(x423+x422+x470+x471+x472);
evalcond[0]=(((sj0*x430))+(((-1.0)*x431*x440))+(((0.999999680000154)*x433))+(((-1.0)*x474))+x476+(((-0.005)*sj1))+(((0.000799999744000123)*cj1*x447))+((sj1*x438)));
evalcond[1]=((0.165)+(((-1.0)*x430*x431))+(((0.005)*cj1))+(((-1.0)*x435*x450))+(((0.000799999744000123)*sj0*x443))+(((0.999999680000154)*x428))+(((-1.0)*x473))+x477+(((-1.0)*x438*x450)));
evalcond[2]=((-0.002796)+((x435*x448))+(((-1.0)*x426))+(((-1.0)*x425))+(((-1.0)*x424))+(((-1.0)*x443*x452))+(((-0.329999894400051)*x428))+((x430*x455))+x475+((x438*x448))+(((0.01)*x435))+(((0.01)*x438))+(((-0.00165)*cj1)));
evalcond[3]=((((3.99999872000061e-6)*r02*sj1))+(((-1.0)*x427*x437))+((x428*x461))+((r00*x428*x431))+((x434*x439))+(((-1.0)*x476))+(((-0.999999680000154)*sj1*x436))+(((-1.0)*x434*x447))+(((-1.0)*sj0*x429*x430))+(((-1.0)*sj1*x429*x438))+x474+((x430*x445))+((x432*x437))+(((-1.0)*x432*x433))+((x427*x433)));
evalcond[4]=(((x432*x451))+(((-1.0)*cj1*x429*x435))+(((-1.0)*cj1*x429*x438))+(((0.00013199995776002)*r02))+((x428*x432))+((r00*x431*x433))+((x433*x461))+(((-1.0)*x427*x428))+(((-1.0)*x473))+(((-1.0)*x430*x453))+(((-0.999999680000154)*cj1*x436))+((x440*x445))+x477+(((0.164999947200025)*x432))+((x442*x443))+(((-1.0)*x427*x451))+(((-0.164999947200025)*x427))+(((3.99999872000061e-6)*x434)));
evalcond[5]=((0.024454)+((x435*x449))+((x432*x458))+(((1.99999936000031)*x438*x446))+((x425*x429))+(((-0.33)*x428*x432))+(((-1.99999936000031)*x441*x442))+(((-0.0272499912800042)*x432))+(((-1.0)*x432*x444))+(((0.33)*x430*x453))+(((0.00999999680000153)*x436))+(((-1.0)*x432*x460))+(((-1.0)*x432*x464))+(((-1.3199995776002e-6)*x434))+(((0.0272499912800042)*x427))+(((-7.99999744000123e-6)*sj0*x454))+(((1.99999936000031)*pz*r02*x439))+(((-0.329999894400051)*r00*x440))+(((-1.0)*x426*x429))+(((0.000263999915520041)*x434*x435))+(((0.000263999915520041)*x434*x438))+x475+(((-1.0)*r01*x433*x452))+(((-0.00999999680000153)*x446))+(((-0.33)*x442*x443))+(((-1.0)*x424*x429))+((x427*x460))+(((0.00159999948800025)*r00*x441))+((x438*x449))+(((-1.99999936000031)*x435*x436))+(((0.00159999948800025)*py*x454))+(((-1.0)*r00*x433*x455))+(((0.329999894400051)*cj1*x436))+((x427*x458))+((x427*x444))+(((-2.17999930240033e-5)*r02))+(((-1.0)*x427*x464))+(((-7.99999744000123e-6)*cj0*pz*r00))+(((0.33)*x427*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x478=(sj1*sj2);
IkReal x479=((0.999999680000154)*r02);
IkReal x480=((0.000799999744000123)*r00);
IkReal x481=(cj2*sj1);
IkReal x482=(r01*sj0);
IkReal x483=(cj0*r00);
IkReal x484=(cj1*cj2);
IkReal x485=(cj1*sj2);
IkReal x486=((0.000799999744000123)*cj0*r01);
IkReal x487=(cj1*x483);
IkReal x488=(sj0*x485);
CheckValue<IkReal> x489 = IKatan2WithCheck(IkReal((((x485*x486))+((x483*x484))+(((-1.0)*x478*x482))+(((-1.0)*x478*x483))+((x481*x486))+(((-1.0)*x480*x488))+(((-1.0)*x479*x485))+(((-1.0)*x479*x481))+((x482*x484))+(((-1.0)*sj0*x480*x481)))),IkReal(((((-1.0)*x484*x486))+((sj0*x480*x484))+(((-1.0)*x478*x479))+((x483*x485))+((x481*x483))+((x481*x482))+((x478*x486))+((x482*x485))+((x479*x484))+(((-1.0)*sj0*x478*x480)))),IKFAST_ATAN2_MAGTHRESH);
if(!x489.valid){
continue;
}
CheckValue<IkReal> x490=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x490.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x489.value)+(((1.5707963267949)*(x490.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x491=IKcos(j3);
IkReal x492=IKsin(j3);
IkReal x493=py*py;
IkReal x494=pz*pz;
IkReal x495=px*px;
IkReal x496=(r00*sj0);
IkReal x497=((0.000799999744000123)*sj1);
IkReal x498=(sj0*sj1);
IkReal x499=(cj2*sj4);
IkReal x500=((0.999999680000154)*sj1);
IkReal x501=(px*r01);
IkReal x502=((0.000799999744000123)*r02);
IkReal x503=(pz*r00);
IkReal x504=((0.329999894400051)*cj0);
IkReal x505=(cj0*py);
IkReal x506=(cj0*r01);
IkReal x507=(cj1*px);
IkReal x508=((2.0)*py);
IkReal x509=((0.999999680000154)*r02);
IkReal x510=(py*sj0);
IkReal x511=(cj1*pz);
IkReal x512=(py*r01);
IkReal x513=(py*r00);
IkReal x514=(cj2*cj4);
IkReal x515=(px*sj1);
IkReal x516=(r01*sj0);
IkReal x517=((0.00999999680000153)*cj0);
IkReal x518=(pz*sj1);
IkReal x519=(cj1*r02);
IkReal x520=(pz*r02);
IkReal x521=((0.106)*cj4);
IkReal x522=((0.028)*sj2);
IkReal x523=((0.000799999744000123)*cj1);
IkReal x524=((0.00159999948800025)*px);
IkReal x525=(px*r02);
IkReal x526=(sj2*sj4);
IkReal x527=(px*sj0);
IkReal x528=((7.99999744000123e-6)*sj1);
IkReal x529=((7.99999744000123e-6)*cj1);
IkReal x530=((1.0)*r02);
IkReal x531=((2.0)*cj0);
IkReal x532=((0.097)*cj2);
IkReal x533=((0.01)*r00);
IkReal x534=(r02*sj1);
IkReal x535=((0.00159999948800025)*r02);
IkReal x536=(cj4*sj2);
IkReal x537=(px*r00);
IkReal x538=((0.00013199995776002)*sj1);
IkReal x539=((0.999999680000154)*cj1);
IkReal x540=((7.99999744000123e-6)*cj0);
IkReal x541=((0.00164999947200025)*cj1);
IkReal x542=((0.00999999680000153)*r02);
IkReal x543=((0.00499999840000077)*cj1);
IkReal x544=((0.00499999840000077)*sj1);
IkReal x545=(cj0*r00);
IkReal x546=((0.00013199995776002)*cj1);
IkReal x547=(cj0*px);
IkReal x548=((0.000263999915520041)*r02);
IkReal x549=((0.329999894400051)*cj1);
IkReal x550=((2.17999930240033e-5)*cj1);
IkReal x551=((0.00999999680000153)*pz);
IkReal x552=((0.028)*cj4);
IkReal x553=((2.17599930368033e-5)*sj1);
IkReal x554=((0.999999680000154)*x493);
IkReal x555=((0.01)*x520);
IkReal x556=(cj1*x545);
IkReal x557=((1.0)*x493);
IkReal x558=(cj1*x510);
IkReal x559=(r02*x495);
IkReal x560=((0.004068)*x492);
IkReal x561=(cj1*x494);
IkReal x562=((0.016836)*x491);
IkReal x563=(sj4*x492);
IkReal x564=((0.016606)*x491);
IkReal x565=((0.055)*x491);
IkReal x566=(sj1*x545);
IkReal x567=((0.023644)*x491);
IkReal x568=((0.999999680000154)*x494);
IkReal x569=((0.055)*x492);
IkReal x570=((1.0)*x494);
IkReal x571=((0.004734)*x492);
IkReal x572=((0.097)*x492);
IkReal x573=((1.0)*x495);
IkReal x574=((0.999999680000154)*x495);
IkReal x575=((0.097)*sj2*x491);
evalcond[0]=(((x492*x536))+((cj1*x509))+((x496*x523))+(((-1.0)*x506*x523))+x566+(((-1.0)*x491*x514))+((r01*x498)));
evalcond[1]=((((-1.0)*x556))+(((-1.0)*cj1*x516))+((x492*x514))+(((-1.0)*x497*x506))+((x496*x497))+((x491*x536))+((r02*x500)));
evalcond[2]=(((x492*x532))+(((0.106)*sj2))+(((0.999999680000154)*x511))+((py*x498))+((cj0*x515))+(((-0.028)*cj2))+(((-1.0)*x505*x523))+(((0.000799999744000123)*sj0*x507))+x575+(((-0.005)*sj1))+((sj2*x569))+(((-1.0)*cj2*x565)));
evalcond[3]=((0.165)+(((0.005)*cj1))+(((-1.0)*x558))+(((-1.0)*x497*x505))+(((-1.0)*sj2*x572))+((cj2*x569))+((x491*x532))+(((0.106)*cj2))+x522+((x497*x527))+((pz*x500))+(((-1.0)*cj0*x507))+((sj2*x565)));
evalcond[4]=(((x492*x521))+(((0.165)*cj1*x516))+(((0.165)*x556))+(((-1.0)*x537))+(((-1.0)*x520))+((x491*x552))+(((-1.0)*x512))+(((-0.164999947200025)*x534))+(((0.055)*cj4))+((x506*x538))+(((0.005)*x545))+(((-1.0)*x496*x538))+(((0.005)*x516)));
evalcond[5]=((-0.002796)+(((0.33)*x558))+(((-0.000263999915520041)*px*x498))+(((0.000263999915520041)*sj1*x505))+(((0.01)*x547))+(((-1.0)*x557))+(((0.33)*cj0*x507))+(((-1.0)*x573))+(((-1.0)*x570))+x567+(((0.01)*x510))+(((-0.329999894400051)*x518))+(((-0.00165)*cj1))+(((0.006228)*x492)));
evalcond[6]=((((0.999999680000154)*cj0*x503))+(((3.99999872000061e-6)*x496))+(((0.164999947200025)*x519))+(((-1.0)*x492*x552))+((x496*x546))+((x491*x521))+(((-1.0)*x506*x546))+(((0.999999680000154)*pz*x516))+(((-1.0)*x509*x547))+(((0.097)*cj4))+(((0.000799999744000123)*x501))+(((0.165)*x566))+(((-3.99999872000061e-6)*x506))+(((-0.000799999744000123)*x513))+(((0.165)*r01*x498))+(((-1.0)*x509*x510))+(((0.00499999840000077)*r02)));
evalcond[7]=(((x496*x511))+((cj0*x497*x503))+(((-0.028)*x499))+((pz*x497*x516))+(((-1.0)*cj0*x497*x525))+(((3.99999872000061e-6)*x534))+(((-1.0)*x499*x565))+(((0.106)*x526))+(((-1.0)*sj0*x507*x530))+((x499*x572))+((x500*x513))+(((0.097)*x491*x526))+(((-1.0)*x506*x511))+((x526*x569))+((x506*x544))+(((-1.0)*r02*x497*x510))+((x505*x519))+(((-1.0)*x500*x501))+(((-1.0)*x496*x544)));
evalcond[8]=((((-1.0)*cj0*x502*x507))+(((0.00013199995776002)*r02))+(((-0.164999947200025)*x496))+(((0.000799999744000123)*x511*x516))+(((-1.0)*sj4*x522))+(((-1.0)*x499*x569))+(((-1.0)*x501*x539))+(((-0.097)*x491*x499))+((x513*x539))+((cj0*x503*x523))+((x526*x572))+(((3.99999872000061e-6)*x519))+(((0.164999947200025)*x506))+(((-1.0)*sj1*x505*x530))+(((-1.0)*x502*x558))+(((-0.106)*x499))+(((-1.0)*x526*x565))+(((-1.0)*x496*x518))+((x506*x543))+((x498*x525))+((x506*x518))+(((-1.0)*x496*x543)));
evalcond[9]=((((-0.00999999680000153)*x513))+(((0.00159999948800025)*pz*x512))+(((-0.024454)*sj4))+(((0.33)*x505*x534))+(((-1.0)*x496*x574))+(((-1.0)*sj4*x567))+((x494*x502))+(((-7.99999744000123e-6)*pz*x516))+(((-0.000263999915520041)*cj0*cj1*x503))+((cj0*x507*x548))+(((1.99999936000031)*x505*x520))+(((1.99999936000031)*x505*x537))+((x496*x554))+(((-0.006228)*x563))+(((-0.33)*x498*x525))+(((-1.0)*x503*x540))+(((-1.0)*x495*x502))+((x496*x541))+((x503*x524))+(((0.00999999680000153)*x501))+(((-0.33)*x506*x518))+(((-1.0)*x506*x541))+((x525*x540))+(((0.000263999915520041)*x510*x519))+(((-1.99999936000031)*x520*x527))+(((0.33)*x496*x518))+((x506*x554))+(((-1.0)*x513*x549))+(((-1.0)*x493*x502))+((x496*x568))+((x501*x549))+(((-1.0)*x506*x574))+(((7.99999744000123e-6)*r02*x510))+(((-0.0272499912800042)*x506))+(((-0.000263999915520041)*x511*x516))+(((-2.17999930240033e-5)*r02))+(((-1.3199995776002e-6)*x519))+(((-1.99999936000031)*x501*x510))+(((-1.0)*x506*x568))+(((0.0272499912800042)*x496)));
evalcond[10]=((((-1.0)*x556*x557))+(((-0.01)*cj1*x512))+(((-1.0)*x498*x520*x524))+(((0.00159999948800025)*r00*x505*x515))+((r02*sj0*x508*x511))+((r01*x498*x551))+((x507*x520*x531))+(((-1.0)*r02*x494*x500))+((x494*x496*x497))+(((-1.0)*x516*x561))+(((-1.0)*x507*x533))+(((-1.0)*x494*x497*x506))+(((-1.0)*cj1*x516*x573))+(((2.0)*cj1*x501*x505))+((x500*x559))+((x505*x518*x535))+(((-1.0)*x495*x496*x497))+(((0.00165)*x516))+(((0.017484)*x536))+(((-0.0271999912960042)*x534))+(((-1.0)*x514*x560))+(((-1.0)*x514*x564))+(((-0.33)*x520))+(((-0.33)*x512))+(((-0.33)*x537))+(((0.00165)*x545))+((x496*x507*x508))+(((-0.017092)*x514))+(((0.02725)*x556))+((sj1*x503*x517))+((x495*x556))+((x506*x553))+((x501*x528))+(((-1.0)*x495*x497*x506))+((r02*x493*x500))+(((-1.0)*x496*x553))+(((-1.0)*py*x498*x542))+((x536*x571))+(((-1.0)*r02*x515*x517))+(((-1.0)*x513*x528))+(((0.02725)*cj1*x516))+((x493*x496*x497))+((x536*x562))+(((-1.99999936000031)*x512*x518))+((cj1*x493*x516))+(((-0.00159999948800025)*py*x498*x501))+(((-1.0)*x556*x570))+(((-0.01)*r02*x511))+((x493*x497*x506))+(((-1.99999936000031)*x503*x515)));
evalcond[11]=((((-1.99999936000031)*x511*x512))+(((-1.0)*x495*x496*x523))+(((-1.0)*x566*x573))+(((-1.0)*x509*x561))+(((-1.0)*r02*x507*x517))+(((-0.00159999948800025)*sj0*x507*x520))+(((0.00999999680000153)*x511*x516))+(((-0.017484)*x514))+((x493*x566))+((x493*x506*x523))+(((-1.3199995776002e-6)*x506))+(((-1.0)*x514*x571))+((cj1*x503*x517))+(((-1.0)*x495*x506*x523))+((x496*x550))+(((-1.0)*x504*x525))+(((0.01)*r02*x518))+(((0.0272)*r01*x498))+((x515*x533))+((x494*x496*x523))+(((-1.0)*x506*x550))+(((-1.0)*r01*x498*x557))+((cj1*x493*x509))+(((-2.0)*sj1*x501*x505))+(((1.3199995776002e-6)*x496))+(((-1.0)*x496*x508*x515))+(((-1.0)*x514*x562))+(((0.0272)*x566))+(((-1.0)*x536*x560))+(((-1.0)*x536*x564))+((x505*x511*x535))+(((-1.0)*x515*x520*x531))+(((-0.00159999948800025)*x501*x558))+(((0.00159999948800025)*r00*x505*x507))+(((0.0272499912800042)*x519))+((x493*x496*x523))+(((-0.329999894400051)*r02*x510))+((r01*x494*x498))+((cj1*x495*x509))+(((-1.99999936000031)*x503*x507))+(((-1.0)*x494*x506*x523))+((x501*x529))+((x503*x504))+(((-0.000263999915520041)*x513))+(((-0.00999999680000153)*x510*x519))+(((0.329999894400051)*pz*x516))+(((-1.0)*x498*x508*x520))+(((-1.0)*x513*x529))+((r01*x495*x498))+(((0.000263999915520041)*x501))+((x494*x566))+(((0.01)*sj1*x512))+(((-0.017092)*x536))+(((0.00164999947200025)*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }
}
}
    }
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "4587f77697661977e41f95829c9a1215"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
