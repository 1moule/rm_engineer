/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-03-31 16:06:39.797107
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION == 0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
                                                                                                                        #ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
                                                                                                                        #ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
void dgetrf_(const int *m, const int *n, double *a, const int *lda, int *ipiv, int *info);
void zgetrf_(const int *m, const int *n, std::complex<double> *a, const int *lda, int *ipiv, int *info);
void dgetri_(const int *n, const double *a, const int *lda, int *ipiv, double *work, const int *lwork, int *info);
void dgesv_(const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
void dgetrs_(const char *trans,
             const int *n,
             const int *nrhs,
             double *a,
             const int *lda,
             int *ipiv,
             double *b,
             const int *ldb,
             int *info);
void dgeev_(const char *jobvl,
            const char *jobvr,
            const int *n,
            double *a,
            const int *lda,
            double *wr,
            double *wi,
            double *vl,
            const int *ldvl,
            double *vr,
            const int *ldvr,
            double *work,
            const int *lwork,
            int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f * f; }
inline double IKsqr(double f) { return f * f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif

inline float IKasin(float f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH
                    && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
  if (f <= -1) return float(-IKPI_2);
  else if (f >= 1) return float(IKPI_2);
  return asinf(f);
}
inline double IKasin(double f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH
                    && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
  if (f <= -1) return -IKPI_2;
  else if (f >= 1) return IKPI_2;
  return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y) {
  while (x < 0) {
    x += y;
  }
  return fmodf(x, y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y) {
  while (x < 0) {
    x += y;
  }
  return fmod(x, y);
}

inline float IKacos(float f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH
                    && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
  if (f <= -1) return float(IKPI);
  else if (f >= 1) return float(0);
  return acosf(f);
}
inline double IKacos(double f) {
  IKFAST_ASSERT(f > -1 - IKFAST_SINCOS_THRESH
                    && f < 1 + IKFAST_SINCOS_THRESH); // any more error implies something is wrong with the solver
  if (f <= -1) return IKPI;
  else if (f >= 1) return 0;
  return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) {
  if (f <= 0.0f) return 0.0f;
  return sqrtf(f);
}
inline double IKsqrt(double f) {
  if (f <= 0.0) return 0.0;
  return sqrt(f);
}
inline float IKatan2Simple(float fy, float fx) {
  return atan2f(fy, fx);
}
inline float IKatan2(float fy, float fx) {
  if (isnan(fy)) {
    IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
    return float(IKPI_2);
  } else if (isnan(fx)) {
    return 0;
  }
  return atan2f(fy, fx);
}
inline double IKatan2Simple(double fy, double fx) {
  return atan2(fy, fx);
}
inline double IKatan2(double fy, double fx) {
  if (isnan(fy)) {
    IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
    return IKPI_2;
  } else if (isnan(fx)) {
    return 0;
  }
  return atan2(fy, fx);
}

template<typename T>
struct CheckValue {
  T value;
  bool valid;
};

template<typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon) {
  CheckValue<T> ret;
  ret.valid = false;
  ret.value = 0;
  if (!isnan(fy) && !isnan(fx)) {
    if (IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH) {
      ret.value = IKatan2Simple(fy, fx);
      ret.valid = true;
    }
  }
  return ret;
}

inline float IKsign(float f) {
  if (f > 0) {
    return float(1);
  } else if (f < 0) {
    return float(-1);
  }
  return 0;
}

inline double IKsign(double f) {
  if (f > 0) {
    return 1.0;
  } else if (f < 0) {
    return -1.0;
  }
  return 0;
}

template<typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n) {
  CheckValue<T> ret;
  ret.valid = true;
  if (n == 0) {
    ret.value = 1.0;
    return ret;
  } else if (n == 1) {
    ret.value = f;
    return ret;
  } else if (n < 0) {
    if (f == 0) {
      ret.valid = false;
      ret.value = (T) 1.0e30;
      return ret;
    }
    if (n == -1) {
      ret.value = T(1.0) / f;
      return ret;
    }
  }

  int num = n > 0 ? n : -n;
  if (num == 2) {
    ret.value = f * f;
  } else if (num == 3) {
    ret.value = f * f * f;
  } else {
    ret.value = 1.0;
    while (num > 0) {
      if (num & 1) {
        ret.value *= f;
      }
      num >>= 1;
      f *= f;
    }
  }

  if (n < 0) {
    ret.value = T(1.0) / ret.value;
  }
  return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal *j, IkReal *eetrans, IkReal *eerot) {
  IkReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20;
  x0 = IKcos(j[0]);
  x1 = IKcos(j[1]);
  x2 = IKsin(j[0]);
  x3 = IKcos(j[2]);
  x4 = IKsin(j[1]);
  x5 = IKsin(j[2]);
  x6 = IKcos(j[4]);
  x7 = IKsin(j[3]);
  x8 = IKcos(j[3]);
  x9 = IKsin(j[4]);
  x10 = ((0.145) * x2);
  x11 = ((1.0) * x0);
  x12 = ((1.0) * x8);
  x13 = ((1.0) * x7);
  x14 = ((0.16) * x1);
  x15 = ((1.0) * x2);
  x16 = ((0.145) * x0);
  x17 = (x1 * x3);
  x18 = (x4 * x5);
  x19 = (x1 * x5);
  x20 = ((1.0) * x3 * x4);
  eetrans[0] = ((0.133) + (((0.05909) * x0)) + ((x0 * x14)) + (((-1.0) * x16 * x18)) + ((x16 * x17)));
  eetrans[1] = ((((0.05909) * x2)) + ((x14 * x2)) + (((-1.0) * x10 * x18)) + ((x10 * x17)));
  eetrans[2] = ((0.228) + (((-0.145) * x3 * x4)) + (((-0.16) * x4)) + (((-0.145) * x19)));
  IkReal x21 = ((1.0) * x11);
  eerot[0] = ((((-1.0) * x6 * ((((x12 * (((((-1.0) * x19 * x21)) + (((-1.0) * x21 * x3 * x4))))))
      + ((x13 * (((((-1.0) * x17 * x21)) + ((x11 * x18)))))))))) + ((x2 * x9)));
  IkReal x22 = ((1.0) * x15);
  eerot[1] = ((((-1.0) * x11 * x9)) + (((-1.0) * x6 * ((((x13 * (((((-1.0) * x17 * x22)) + ((x15 * x18))))))
      + ((x12 * (((((-1.0) * x19 * x22)) + (((-1.0) * x22 * x3 * x4)))))))))));
  eerot[2] = ((-1.0) * x6 * ((((x12 * (((((-1.0) * x17)) + x18)))) + ((x13 * (((((1.0) * x19)) + x20)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int *GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
 public:
  IkReal j4, cj4, sj4, htj4, j4mul, j5, cj5, sj5, htj5, j5mul, j6, cj6, sj6, htj6, j6mul, j7, cj7, sj7, htj7, j7mul, j8,
      cj8, sj8, htj8, j8mul, new_r00, r00, rxp0_0, new_r01, r01, rxp0_1, new_r02, r02, rxp0_2, new_px, px, npx, new_py,
      py, npy, new_pz, pz, npz, pp;
  unsigned char _ij4[2], _nj4, _ij5[2], _nj5, _ij6[2], _nj6, _ij7[2], _nj7, _ij8[2], _nj8;

  IkReal j100, cj100, sj100;
  unsigned char _ij100[2], _nj100;
  bool ComputeIk(const IkReal *eetrans,
                 const IkReal *eerot,
                 const IkReal *pfree,
                 IkSolutionListBase<IkReal> &solutions) {
    j4 = numeric_limits<IkReal>::quiet_NaN();
    _ij4[0] = -1;
    _ij4[1] = -1;
    _nj4 = -1;
    j5 = numeric_limits<IkReal>::quiet_NaN();
    _ij5[0] = -1;
    _ij5[1] = -1;
    _nj5 = -1;
    j6 = numeric_limits<IkReal>::quiet_NaN();
    _ij6[0] = -1;
    _ij6[1] = -1;
    _nj6 = -1;
    j7 = numeric_limits<IkReal>::quiet_NaN();
    _ij7[0] = -1;
    _ij7[1] = -1;
    _nj7 = -1;
    j8 = numeric_limits<IkReal>::quiet_NaN();
    _ij8[0] = -1;
    _ij8[1] = -1;
    _nj8 = -1;
    for (int dummyiter = 0; dummyiter < 1; ++dummyiter) {
      solutions.Clear();
      px = eetrans[0];
      py = eetrans[1];
      pz = eetrans[2];

      r00 = eerot[0];
      r01 = eerot[1];
      r02 = eerot[2];
      px = eetrans[0];
      py = eetrans[1];
      pz = eetrans[2];
      new_r00 = r00;
      new_px = ((-0.133) + px);
      new_r01 = r01;
      new_py = py;
      new_r02 = r02;
      new_pz = ((-0.228) + pz);
      r00 = new_r00;
      r01 = new_r01;
      r02 = new_r02;
      px = new_px;
      py = new_py;
      pz = new_pz;

      pp = ((px * px) + (py * py) + (pz * pz));
      {
        IkReal j4eval[1];
        j4eval[0] = ((IKabs(px)) + (IKabs(py)));
        if (IKabs(j4eval[0]) < 0.0000010000000000) {
          continue; // no branches [j4, j5, j6]

        } else {
          {
            IkReal j4array[2], cj4array[2], sj4array[2];
            bool j4valid[2] = {false};
            _nj4 = 2;
            CheckValue<IkReal> x24 = IKatan2WithCheck(IkReal(((-1.0) * py)), IkReal(px), IKFAST_ATAN2_MAGTHRESH);
            if (!x24.valid) {
              continue;
            }
            IkReal x23 = x24.value;
            j4array[0] = ((-1.0) * x23);
            sj4array[0] = IKsin(j4array[0]);
            cj4array[0] = IKcos(j4array[0]);
            j4array[1] = ((3.14159265358979) + (((-1.0) * x23)));
            sj4array[1] = IKsin(j4array[1]);
            cj4array[1] = IKcos(j4array[1]);
            if (j4array[0] > IKPI) {
              j4array[0] -= IK2PI;
            } else if (j4array[0] < -IKPI) {
              j4array[0] += IK2PI;
            }
            j4valid[0] = true;
            if (j4array[1] > IKPI) {
              j4array[1] -= IK2PI;
            } else if (j4array[1] < -IKPI) {
              j4array[1] += IK2PI;
            }
            j4valid[1] = true;
            for (int ij4 = 0; ij4 < 2; ++ij4) {
              if (!j4valid[ij4]) {
                continue;
              }
              _ij4[0] = ij4;
              _ij4[1] = -1;
              for (int iij4 = ij4 + 1; iij4 < 2; ++iij4) {
                if (j4valid[iij4] && IKabs(cj4array[ij4] - cj4array[iij4]) < IKFAST_SOLUTION_THRESH
                    && IKabs(sj4array[ij4] - sj4array[iij4]) < IKFAST_SOLUTION_THRESH) {
                  j4valid[iij4] = false;
                  _ij4[1] = iij4;
                  break;
                }
              }
              j4 = j4array[ij4];
              cj4 = cj4array[ij4];
              sj4 = sj4array[ij4];

              {
                IkReal j6array[2], cj6array[2], sj6array[2];
                bool j6valid[2] = {false};
                _nj6 = 2;
                cj6array[0] =
                    ((-0.929598532327586) + (((21.551724137931) * (py * py))) + (((21.551724137931) * (px * px)))
                        + (((-2.54698275862069) * cj4 * px)) + (((21.551724137931) * (pz * pz)))
                        + (((-2.54698275862069) * py * sj4)));
                if (cj6array[0] >= -1 - IKFAST_SINCOS_THRESH && cj6array[0] <= 1 + IKFAST_SINCOS_THRESH) {
                  j6valid[0] = j6valid[1] = true;
                  j6array[0] = IKacos(cj6array[0]);
                  sj6array[0] = IKsin(j6array[0]);
                  cj6array[1] = cj6array[0];
                  j6array[1] = -j6array[0];
                  sj6array[1] = -sj6array[0];
                } else if (isnan(cj6array[0])) {
                  // probably any value will work
                  j6valid[0] = true;
                  cj6array[0] = 1;
                  sj6array[0] = 0;
                  j6array[0] = 0;
                }
                for (int ij6 = 0; ij6 < 2; ++ij6) {
                  if (!j6valid[ij6]) {
                    continue;
                  }
                  _ij6[0] = ij6;
                  _ij6[1] = -1;
                  for (int iij6 = ij6 + 1; iij6 < 2; ++iij6) {
                    if (j6valid[iij6] && IKabs(cj6array[ij6] - cj6array[iij6]) < IKFAST_SOLUTION_THRESH
                        && IKabs(sj6array[ij6] - sj6array[iij6]) < IKFAST_SOLUTION_THRESH) {
                      j6valid[iij6] = false;
                      _ij6[1] = iij6;
                      break;
                    }
                  }
                  j6 = j6array[ij6];
                  cj6 = cj6array[ij6];
                  sj6 = sj6array[ij6];

                  {
                    IkReal j5eval[3];
                    IkReal x25 = ((5800.0) * cj6);
                    IkReal x26 = (cj4 * px);
                    IkReal x27 = ((5800.0) * sj6);
                    IkReal x28 = (py * sj4);
                    j5eval[0] = ((1.00484913793103) + cj6);
                    j5eval[1] = IKsign(((1865.0) + (((1856.0) * cj6))));
                    j5eval[2] = ((IKabs(((-378.176) + (((6400.0) * x26)) + (((6400.0) * x28)) + (((-1.0) * pz * x27))
                        + ((x25 * x26)) + ((x25 * x28)) + (((-342.722) * cj6)))))
                        + (IKabs(((((342.722) * sj6)) + (((-1.0) * x27 * x28)) + (((-1.0) * pz * x25))
                            + (((-1.0) * x26 * x27)) + (((-6400.0) * pz))))));
                    if (IKabs(j5eval[0]) < 0.0000010000000000 || IKabs(j5eval[1]) < 0.0000010000000000
                        || IKabs(j5eval[2]) < 0.0000010000000000) {
                      {
                        IkReal j5eval[3];
                        IkReal x29 = (cj4 * px);
                        IkReal x30 = ((29.0) * cj6);
                        IkReal x31 = (pz * sj6);
                        IkReal x32 = (py * sj4);
                        IkReal x33 = ((16.923337282112) * cj6);
                        IkReal x34 = ((200.0) * pz);
                        j5eval[0] = ((1.10344827586207) + (((-1.0) * x29 * x33)) + (((-18.6740273457788) * x32)) + cj6
                            + (((-18.6740273457788) * x29)) + (((-1.0) * x32 * x33)) + (((-16.923337282112) * x31)));
                        j5eval[1] =
                            IKsign(((1.89088) + (((-29.0) * x31)) + (((-1.0) * x29 * x30)) + (((-1.0) * x30 * x32))
                                + (((-32.0) * x29)) + (((1.71361) * cj6)) + (((-32.0) * x32))));
                        j5eval[2] =
                            ((IKabs((((x29 * x34)) + (((4.205) * cj6 * sj6)) + (((-11.818) * pz)) + (((4.64) * sj6))
                                + ((x32 * x34)))))
                                + (IKabs(((-5.12) + (((-4.205) * (cj6 * cj6))) + ((pz * x34)) + (((-9.28) * cj6))))));
                        if (IKabs(j5eval[0]) < 0.0000010000000000 || IKabs(j5eval[1]) < 0.0000010000000000
                            || IKabs(j5eval[2]) < 0.0000010000000000) {
                          {
                            IkReal j5eval[3];
                            IkReal x35 = py * py;
                            IkReal x36 = cj4 * cj4;
                            IkReal x37 = px * px;
                            IkReal x38 = pz * pz;
                            IkReal x39 = ((29.0) * cj6);
                            IkReal x40 = (cj4 * px);
                            IkReal x41 = (py * sj4);
                            IkReal x42 = ((29.0) * sj6);
                            IkReal x43 = ((286.399344764123) * x35);
                            IkReal x44 = ((200.0) * x35);
                            IkReal x45 = (x36 * x37);
                            j5eval[0] = ((-1.0) + ((x36 * x43)) + (((-1.0) * x43)) + (((-286.399344764123) * x45))
                                + (((-286.399344764123) * x38)) + (((-572.798689528246) * x40 * x41))
                                + (((33.8466745642241) * x40)) + (((33.8466745642241) * x41)));
                            j5eval[1] =
                                ((IKabs(((1.89088) + ((pz * x42)) + (((-1.0) * x39 * x40)) + (((-1.0) * x39 * x41))
                                    + (((1.71361) * cj6)) + (((-32.0) * x40)) + (((-32.0) * x41)))))
                                    + (IKabs((((pz * x39)) + ((x41 * x42)) + ((x40 * x42)) + (((-1.71361) * sj6))
                                        + (((32.0) * pz))))));
                            j5eval[2] = IKsign(((-0.69832562) + ((x36 * x44)) + (((-1.0) * x44)) + (((23.636) * x40))
                                + (((23.636) * x41)) + (((-200.0) * x38)) + (((-200.0) * x45))
                                + (((-400.0) * x40 * x41))));
                            if (IKabs(j5eval[0]) < 0.0000010000000000 || IKabs(j5eval[1]) < 0.0000010000000000
                                || IKabs(j5eval[2]) < 0.0000010000000000) {
                              continue; // no branches [j5]

                            } else {
                              {
                                IkReal j5array[1], cj5array[1], sj5array[1];
                                bool j5valid[1] = {false};
                                _nj5 = 1;
                                IkReal x46 = cj4 * cj4;
                                IkReal x47 = py * py;
                                IkReal x48 = ((29.0) * cj6);
                                IkReal x49 = (cj4 * px);
                                IkReal x50 = ((29.0) * sj6);
                                IkReal x51 = (py * sj4);
                                IkReal x52 = ((200.0) * x46);
                                CheckValue<IkReal> x53 =
                                    IKPowWithIntegerCheck(IKsign(((-0.69832562) + (((23.636) * x51))
                                                              + (((23.636) * x49)) + (((-200.0) * x47)) + (((-200.0) * (pz * pz)))
                                                              + ((x47 * x52)) + (((-400.0) * x49 * x51)) + (((-1.0) * x52 * (px * px))))),
                                                          -1);
                                if (!x53.valid) {
                                  continue;
                                }
                                CheckValue<IkReal> x54 =
                                    IKatan2WithCheck(IkReal((((pz * x48)) + ((x50 * x51)) + ((x49 * x50))
                                                         + (((-1.71361) * sj6)) + (((32.0) * pz)))),
                                                     IkReal(((1.89088) + (((-1.0) * x48 * x49)) + (((-1.0) * x48 * x51))
                                                         + (((-32.0) * x51)) + (((1.71361) * cj6)) + (((-32.0) * x49))
                                                         + ((pz * x50)))),
                                                     IKFAST_ATAN2_MAGTHRESH);
                                if (!x54.valid) {
                                  continue;
                                }
                                j5array[0] = ((-1.5707963267949) + (((1.5707963267949) * (x53.value))) + (x54.value));
                                sj5array[0] = IKsin(j5array[0]);
                                cj5array[0] = IKcos(j5array[0]);
                                if (j5array[0] > IKPI) {
                                  j5array[0] -= IK2PI;
                                } else if (j5array[0] < -IKPI) {
                                  j5array[0] += IK2PI;
                                }
                                j5valid[0] = true;
                                for (int ij5 = 0; ij5 < 1; ++ij5) {
                                  if (!j5valid[ij5]) {
                                    continue;
                                  }
                                  _ij5[0] = ij5;
                                  _ij5[1] = -1;
                                  for (int iij5 = ij5 + 1; iij5 < 1; ++iij5) {
                                    if (j5valid[iij5] && IKabs(cj5array[ij5] - cj5array[iij5]) < IKFAST_SOLUTION_THRESH
                                        && IKabs(sj5array[ij5] - sj5array[iij5]) < IKFAST_SOLUTION_THRESH) {
                                      j5valid[iij5] = false;
                                      _ij5[1] = iij5;
                                      break;
                                    }
                                  }
                                  j5 = j5array[ij5];
                                  cj5 = cj5array[ij5];
                                  sj5 = sj5array[ij5];
                                  {
                                    IkReal evalcond[5];
                                    IkReal x55 = IKsin(j5);
                                    IkReal x56 = IKcos(j5);
                                    IkReal x57 = (cj4 * px);
                                    IkReal x58 = ((0.145) * cj6);
                                    IkReal x59 = (py * sj4);
                                    IkReal x60 = ((0.145) * sj6);
                                    IkReal x61 = (pz * x55);
                                    IkReal x62 = ((0.32) * x56);
                                    IkReal x63 = ((1.0) * x56);
                                    evalcond[0] = ((((0.16) * x55)) + pz + ((x56 * x60)) + ((x55 * x58)));
                                    evalcond[1] =
                                        ((((-0.05909) * x55)) + x60 + ((pz * x56)) + ((x55 * x59)) + ((x55 * x57)));
                                    evalcond[2] = ((0.05909) + (((0.16) * x56)) + (((-1.0) * x55 * x60)) + ((x56 * x58))
                                        + (((-1.0) * x57)) + (((-1.0) * x59)));
                                    evalcond[3] = ((0.16) + (((-1.0) * x59 * x63)) + x58 + x61 + (((-1.0) * x57 * x63))
                                        + (((0.05909) * x56)));
                                    evalcond[4] =
                                        ((-0.0080666281) + (((-1.0) * (px * px))) + ((x59 * x62)) + ((x57 * x62))
                                            + (((-1.0) * (pz * pz))) + (((-0.0189088) * x56)) + (((0.11818) * x59))
                                            + (((0.11818) * x57)) + (((-1.0) * (py * py))) + (((-0.32) * x61)));
                                    if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH
                                        || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH
                                        || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH
                                        || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH
                                        || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH) {
                                      continue;
                                    }
                                  }

                                  innerfn(solutions);
                                }
                              }

                            }

                          }

                        } else {
                          {
                            IkReal j5array[1], cj5array[1], sj5array[1];
                            bool j5valid[1] = {false};
                            _nj5 = 1;
                            IkReal x80 = ((29.0) * cj6);
                            IkReal x81 = (cj4 * px);
                            IkReal x82 = (py * sj4);
                            IkReal x83 = ((200.0) * pz);
                            CheckValue<IkReal> x84 = IKPowWithIntegerCheck(IKsign(((1.89088) + (((-29.0) * pz * sj6))
                                + (((-1.0) * x80 * x81)) + (((-1.0) * x80 * x82)) + (((1.71361) * cj6))
                                + (((-32.0) * x82)) + (((-32.0) * x81)))), -1);
                            if (!x84.valid) {
                              continue;
                            }
                            CheckValue<IkReal> x85 =
                                IKatan2WithCheck(IkReal(((((4.205) * cj6 * sj6)) + ((x82 * x83)) + ((x81 * x83))
                                                     + (((-11.818) * pz)) + (((4.64) * sj6)))),
                                                 IkReal(((-5.12) + (((-4.205) * (cj6 * cj6))) + ((pz * x83))
                                                     + (((-9.28) * cj6)))),
                                                 IKFAST_ATAN2_MAGTHRESH);
                            if (!x85.valid) {
                              continue;
                            }
                            j5array[0] = ((-1.5707963267949) + (((1.5707963267949) * (x84.value))) + (x85.value));
                            sj5array[0] = IKsin(j5array[0]);
                            cj5array[0] = IKcos(j5array[0]);
                            if (j5array[0] > IKPI) {
                              j5array[0] -= IK2PI;
                            } else if (j5array[0] < -IKPI) {
                              j5array[0] += IK2PI;
                            }
                            j5valid[0] = true;
                            for (int ij5 = 0; ij5 < 1; ++ij5) {
                              if (!j5valid[ij5]) {
                                continue;
                              }
                              _ij5[0] = ij5;
                              _ij5[1] = -1;
                              for (int iij5 = ij5 + 1; iij5 < 1; ++iij5) {
                                if (j5valid[iij5] && IKabs(cj5array[ij5] - cj5array[iij5]) < IKFAST_SOLUTION_THRESH
                                    && IKabs(sj5array[ij5] - sj5array[iij5]) < IKFAST_SOLUTION_THRESH) {
                                  j5valid[iij5] = false;
                                  _ij5[1] = iij5;
                                  break;
                                }
                              }
                              j5 = j5array[ij5];
                              cj5 = cj5array[ij5];
                              sj5 = sj5array[ij5];
                              {
                                IkReal evalcond[5];
                                IkReal x86 = IKsin(j5);
                                IkReal x87 = IKcos(j5);
                                IkReal x88 = (cj4 * px);
                                IkReal x89 = ((0.145) * cj6);
                                IkReal x90 = (py * sj4);
                                IkReal x91 = ((0.145) * sj6);
                                IkReal x92 = (pz * x86);
                                IkReal x93 = ((0.32) * x87);
                                IkReal x94 = ((1.0) * x87);
                                evalcond[0] = (((x87 * x91)) + (((0.16) * x86)) + ((x86 * x89)) + pz);
                                evalcond[1] =
                                    (((x86 * x90)) + ((x86 * x88)) + ((pz * x87)) + (((-0.05909) * x86)) + x91);
                                evalcond[2] = ((0.05909) + (((0.16) * x87)) + (((-1.0) * x86 * x91)) + (((-1.0) * x88))
                                    + (((-1.0) * x90)) + ((x87 * x89)));
                                evalcond[3] = ((0.16) + (((-1.0) * x90 * x94)) + x89 + x92 + (((0.05909) * x87))
                                    + (((-1.0) * x88 * x94)));
                                evalcond[4] = ((-0.0080666281) + (((-1.0) * (px * px))) + (((-0.32) * x92))
                                    + (((-0.0189088) * x87)) + ((x90 * x93)) + ((x88 * x93)) + (((-1.0) * (pz * pz)))
                                    + (((0.11818) * x90)) + (((0.11818) * x88)) + (((-1.0) * (py * py))));
                                if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH
                                    || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH
                                    || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH
                                    || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH
                                    || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH) {
                                  continue;
                                }
                              }

                              innerfn(solutions);
                            }
                          }

                        }

                      }

                    } else {
                      {
                        IkReal j5array[1], cj5array[1], sj5array[1];
                        bool j5valid[1] = {false};
                        _nj5 = 1;
                        IkReal x95 = ((5800.0) * cj6);
                        IkReal x96 = (cj4 * px);
                        IkReal x97 = ((5800.0) * sj6);
                        IkReal x98 = (py * sj4);
                        CheckValue<IkReal> x99 =
                            IKatan2WithCheck(IkReal(((((342.722) * sj6)) + (((-1.0) * pz * x95)) + (((-6400.0) * pz))
                                                 + (((-1.0) * x96 * x97)) + (((-1.0) * x97 * x98)))),
                                             IkReal(((-378.176) + (((-1.0) * pz * x97)) + (((6400.0) * x98))
                                                 + (((6400.0) * x96)) + ((x95 * x96)) + ((x95 * x98))
                                                 + (((-342.722) * cj6)))),
                                             IKFAST_ATAN2_MAGTHRESH);
                        if (!x99.valid) {
                          continue;
                        }
                        CheckValue<IkReal> x100 = IKPowWithIntegerCheck(IKsign(((1865.0) + (((1856.0) * cj6)))), -1);
                        if (!x100.valid) {
                          continue;
                        }
                        j5array[0] = ((-1.5707963267949) + (x99.value) + (((1.5707963267949) * (x100.value))));
                        sj5array[0] = IKsin(j5array[0]);
                        cj5array[0] = IKcos(j5array[0]);
                        if (j5array[0] > IKPI) {
                          j5array[0] -= IK2PI;
                        } else if (j5array[0] < -IKPI) {
                          j5array[0] += IK2PI;
                        }
                        j5valid[0] = true;
                        for (int ij5 = 0; ij5 < 1; ++ij5) {
                          if (!j5valid[ij5]) {
                            continue;
                          }
                          _ij5[0] = ij5;
                          _ij5[1] = -1;
                          for (int iij5 = ij5 + 1; iij5 < 1; ++iij5) {
                            if (j5valid[iij5] && IKabs(cj5array[ij5] - cj5array[iij5]) < IKFAST_SOLUTION_THRESH
                                && IKabs(sj5array[ij5] - sj5array[iij5]) < IKFAST_SOLUTION_THRESH) {
                              j5valid[iij5] = false;
                              _ij5[1] = iij5;
                              break;
                            }
                          }
                          j5 = j5array[ij5];
                          cj5 = cj5array[ij5];
                          sj5 = sj5array[ij5];
                          {
                            IkReal evalcond[5];
                            IkReal x101 = IKsin(j5);
                            IkReal x102 = IKcos(j5);
                            IkReal x103 = (cj4 * px);
                            IkReal x104 = ((0.145) * cj6);
                            IkReal x105 = (py * sj4);
                            IkReal x106 = ((0.145) * sj6);
                            IkReal x107 = (pz * x101);
                            IkReal x108 = ((0.32) * x102);
                            IkReal x109 = ((1.0) * x102);
                            evalcond[0] = ((((0.16) * x101)) + ((x102 * x106)) + pz + ((x101 * x104)));
                            evalcond[1] =
                                (((pz * x102)) + x106 + (((-0.05909) * x101)) + ((x101 * x103)) + ((x101 * x105)));
                            evalcond[2] = ((0.05909) + (((0.16) * x102)) + (((-1.0) * x101 * x106)) + ((x102 * x104))
                                + (((-1.0) * x103)) + (((-1.0) * x105)));
                            evalcond[3] = ((0.16) + (((0.05909) * x102)) + x104 + x107 + (((-1.0) * x103 * x109))
                                + (((-1.0) * x105 * x109)));
                            evalcond[4] =
                                ((-0.0080666281) + (((-0.32) * x107)) + (((-1.0) * (px * px))) + (((-0.0189088) * x102))
                                    + (((0.11818) * x105)) + (((0.11818) * x103)) + ((x103 * x108))
                                    + (((-1.0) * (pz * pz))) + ((x105 * x108)) + (((-1.0) * (py * py))));
                            if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH
                                || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH
                                || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH
                                || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH
                                || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH) {
                              continue;
                            }
                          }

                          innerfn(solutions);
                        }
                      }

                    }

                  }
                }
              }
            }
          }

        }

      }
    }
    return solutions.GetNumSolutions() > 0;
  }
  inline void innerfn(IkSolutionListBase<IkReal> &solutions) {
    for (int fniter = 0; fniter < 1; ++fniter) {
      {
        IkReal j8array[2], cj8array[2], sj8array[2];
        bool j8valid[2] = {false};
        _nj8 = 2;
        sj8array[0] = (((r00 * sj4)) + (((-1.0) * cj4 * r01)));
        if (sj8array[0] >= -1 - IKFAST_SINCOS_THRESH && sj8array[0] <= 1 + IKFAST_SINCOS_THRESH) {
          j8valid[0] = j8valid[1] = true;
          j8array[0] = IKasin(sj8array[0]);
          cj8array[0] = IKcos(j8array[0]);
          sj8array[1] = sj8array[0];
          j8array[1] = j8array[0] > 0 ? (IKPI - j8array[0]) : (-IKPI - j8array[0]);
          cj8array[1] = -cj8array[0];
        } else if (isnan(sj8array[0])) {
          // probably any value will work
          j8valid[0] = true;
          cj8array[0] = 1;
          sj8array[0] = 0;
          j8array[0] = 0;
        }
        for (int ij8 = 0; ij8 < 2; ++ij8) {
          if (!j8valid[ij8]) {
            continue;
          }
          _ij8[0] = ij8;
          _ij8[1] = -1;
          for (int iij8 = ij8 + 1; iij8 < 2; ++iij8) {
            if (j8valid[iij8] && IKabs(cj8array[ij8] - cj8array[iij8]) < IKFAST_SOLUTION_THRESH
                && IKabs(sj8array[ij8] - sj8array[iij8]) < IKFAST_SOLUTION_THRESH) {
              j8valid[iij8] = false;
              _ij8[1] = iij8;
              break;
            }
          }
          j8 = j8array[ij8];
          cj8 = cj8array[ij8];
          sj8 = sj8array[ij8];

          {
            IkReal j7eval[2];
            j7eval[0] = cj8;
            j7eval[1] = IKsign(cj8);
            if (IKabs(j7eval[0]) < 0.0000010000000000 || IKabs(j7eval[1]) < 0.0000010000000000) {
              {
                IkReal evalcond[1];
                bool bgotonextstatement = true;
                do {
                  evalcond[0] = ((-3.14159265358979)
                      + (IKfmod(((3.14159265358979) + (IKabs(((-1.5707963267949) + j8)))), 6.28318530717959)));
                  if (IKabs(evalcond[0]) < 0.0000050000000000) {
                    bgotonextstatement = false;
                    {
                      IkReal j7array[1], cj7array[1], sj7array[1];
                      bool j7valid[1] = {false};
                      _nj7 = 1;
                      j7array[0] = 0;
                      sj7array[0] = IKsin(j7array[0]);
                      cj7array[0] = IKcos(j7array[0]);
                      if (j7array[0] > IKPI) {
                        j7array[0] -= IK2PI;
                      } else if (j7array[0] < -IKPI) {
                        j7array[0] += IK2PI;
                      }
                      j7valid[0] = true;
                      for (int ij7 = 0; ij7 < 1; ++ij7) {
                        if (!j7valid[ij7]) {
                          continue;
                        }
                        _ij7[0] = ij7;
                        _ij7[1] = -1;
                        for (int iij7 = ij7 + 1; iij7 < 1; ++iij7) {
                          if (j7valid[iij7] && IKabs(cj7array[ij7] - cj7array[iij7]) < IKFAST_SOLUTION_THRESH
                              && IKabs(sj7array[ij7] - sj7array[iij7]) < IKFAST_SOLUTION_THRESH) {
                            j7valid[iij7] = false;
                            _ij7[1] = iij7;
                            break;
                          }
                        }
                        j7 = j7array[ij7];
                        cj7 = cj7array[ij7];
                        sj7 = sj7array[ij7];

                        {
                          std::vector<IkSingleDOFSolutionBase<IkReal>> vinfos(5);
                          vinfos[0].jointtype = 1;
                          vinfos[0].foffset = j4;
                          vinfos[0].indices[0] = _ij4[0];
                          vinfos[0].indices[1] = _ij4[1];
                          vinfos[0].maxsolutions = _nj4;
                          vinfos[1].jointtype = 1;
                          vinfos[1].foffset = j5;
                          vinfos[1].indices[0] = _ij5[0];
                          vinfos[1].indices[1] = _ij5[1];
                          vinfos[1].maxsolutions = _nj5;
                          vinfos[2].jointtype = 1;
                          vinfos[2].foffset = j6;
                          vinfos[2].indices[0] = _ij6[0];
                          vinfos[2].indices[1] = _ij6[1];
                          vinfos[2].maxsolutions = _nj6;
                          vinfos[3].jointtype = 1;
                          vinfos[3].foffset = j7;
                          vinfos[3].indices[0] = _ij7[0];
                          vinfos[3].indices[1] = _ij7[1];
                          vinfos[3].maxsolutions = _nj7;
                          vinfos[4].jointtype = 1;
                          vinfos[4].foffset = j8;
                          vinfos[4].indices[0] = _ij8[0];
                          vinfos[4].indices[1] = _ij8[1];
                          vinfos[4].maxsolutions = _nj8;
                          std::vector<int> vfree(0);
                          solutions.AddSolution(vinfos, vfree);
                        }
                      }
                    }

                  }
                } while (0);
                if (bgotonextstatement) {
                  bool bgotonextstatement = true;
                  do {
                    evalcond[0] = ((-3.14159265358979)
                        + (IKfmod(((3.14159265358979) + (IKabs(((1.5707963267949) + j8)))), 6.28318530717959)));
                    if (IKabs(evalcond[0]) < 0.0000050000000000) {
                      bgotonextstatement = false;
                      {
                        IkReal j7array[1], cj7array[1], sj7array[1];
                        bool j7valid[1] = {false};
                        _nj7 = 1;
                        j7array[0] = 0;
                        sj7array[0] = IKsin(j7array[0]);
                        cj7array[0] = IKcos(j7array[0]);
                        if (j7array[0] > IKPI) {
                          j7array[0] -= IK2PI;
                        } else if (j7array[0] < -IKPI) {
                          j7array[0] += IK2PI;
                        }
                        j7valid[0] = true;
                        for (int ij7 = 0; ij7 < 1; ++ij7) {
                          if (!j7valid[ij7]) {
                            continue;
                          }
                          _ij7[0] = ij7;
                          _ij7[1] = -1;
                          for (int iij7 = ij7 + 1; iij7 < 1; ++iij7) {
                            if (j7valid[iij7] && IKabs(cj7array[ij7] - cj7array[iij7]) < IKFAST_SOLUTION_THRESH
                                && IKabs(sj7array[ij7] - sj7array[iij7]) < IKFAST_SOLUTION_THRESH) {
                              j7valid[iij7] = false;
                              _ij7[1] = iij7;
                              break;
                            }
                          }
                          j7 = j7array[ij7];
                          cj7 = cj7array[ij7];
                          sj7 = sj7array[ij7];

                          {
                            std::vector<IkSingleDOFSolutionBase<IkReal>> vinfos(5);
                            vinfos[0].jointtype = 1;
                            vinfos[0].foffset = j4;
                            vinfos[0].indices[0] = _ij4[0];
                            vinfos[0].indices[1] = _ij4[1];
                            vinfos[0].maxsolutions = _nj4;
                            vinfos[1].jointtype = 1;
                            vinfos[1].foffset = j5;
                            vinfos[1].indices[0] = _ij5[0];
                            vinfos[1].indices[1] = _ij5[1];
                            vinfos[1].maxsolutions = _nj5;
                            vinfos[2].jointtype = 1;
                            vinfos[2].foffset = j6;
                            vinfos[2].indices[0] = _ij6[0];
                            vinfos[2].indices[1] = _ij6[1];
                            vinfos[2].maxsolutions = _nj6;
                            vinfos[3].jointtype = 1;
                            vinfos[3].foffset = j7;
                            vinfos[3].indices[0] = _ij7[0];
                            vinfos[3].indices[1] = _ij7[1];
                            vinfos[3].maxsolutions = _nj7;
                            vinfos[4].jointtype = 1;
                            vinfos[4].foffset = j8;
                            vinfos[4].indices[0] = _ij8[0];
                            vinfos[4].indices[1] = _ij8[1];
                            vinfos[4].maxsolutions = _nj8;
                            std::vector<int> vfree(0);
                            solutions.AddSolution(vinfos, vfree);
                          }
                        }
                      }

                    }
                  } while (0);
                  if (bgotonextstatement) {
                    bool bgotonextstatement = true;
                    do {
                      if (1) {
                        bgotonextstatement = false;
                        continue; // branch miss [j7]

                      }
                    } while (0);
                    if (bgotonextstatement) {
                    }
                  }
                }
              }

            } else {
              {
                IkReal j7array[1], cj7array[1], sj7array[1];
                bool j7valid[1] = {false};
                _nj7 = 1;
                IkReal x64 = (cj6 * sj5);
                IkReal x65 = (r01 * sj4);
                IkReal x66 = (cj4 * r00);
                IkReal x67 = ((1.0) * r02);
                IkReal x68 = (sj5 * sj6);
                IkReal x69 = (cj5 * cj6);
                IkReal x70 = (cj5 * sj6);
                CheckValue<IkReal> x71 =
                    IKatan2WithCheck(IkReal(((((-1.0) * x66 * x68)) + (((-1.0) * x65 * x68)) + (((-1.0) * x64 * x67))
                                         + (((-1.0) * x67 * x70)) + ((x66 * x69)) + ((x65 * x69)))),
                                     IkReal((((r02 * x69)) + (((-1.0) * x67 * x68)) + ((x66 * x70)) + ((x64 * x66))
                                         + ((x64 * x65)) + ((x65 * x70)))),
                                     IKFAST_ATAN2_MAGTHRESH);
                if (!x71.valid) {
                  continue;
                }
                CheckValue<IkReal> x72 = IKPowWithIntegerCheck(IKsign(cj8), -1);
                if (!x72.valid) {
                  continue;
                }
                j7array[0] = ((-1.5707963267949) + (x71.value) + (((1.5707963267949) * (x72.value))));
                sj7array[0] = IKsin(j7array[0]);
                cj7array[0] = IKcos(j7array[0]);
                if (j7array[0] > IKPI) {
                  j7array[0] -= IK2PI;
                } else if (j7array[0] < -IKPI) {
                  j7array[0] += IK2PI;
                }
                j7valid[0] = true;
                for (int ij7 = 0; ij7 < 1; ++ij7) {
                  if (!j7valid[ij7]) {
                    continue;
                  }
                  _ij7[0] = ij7;
                  _ij7[1] = -1;
                  for (int iij7 = ij7 + 1; iij7 < 1; ++iij7) {
                    if (j7valid[iij7] && IKabs(cj7array[ij7] - cj7array[iij7]) < IKFAST_SOLUTION_THRESH
                        && IKabs(sj7array[ij7] - sj7array[iij7]) < IKFAST_SOLUTION_THRESH) {
                      j7valid[iij7] = false;
                      _ij7[1] = iij7;
                      break;
                    }
                  }
                  j7 = j7array[ij7];
                  cj7 = cj7array[ij7];
                  sj7 = sj7array[ij7];
                  {
                    IkReal evalcond[2];
                    IkReal x73 = (r02 * sj6);
                    IkReal x74 = (cj6 * sj5);
                    IkReal x75 = (r01 * sj4);
                    IkReal x76 = (cj5 * cj6);
                    IkReal x77 = (cj5 * sj6);
                    IkReal x78 = (cj4 * r00);
                    IkReal x79 = (sj5 * x78);
                    evalcond[0] = (((cj5 * x73)) + ((sj5 * sj6 * x75)) + ((r02 * x74)) + (((-1.0) * x75 * x76))
                        + ((cj8 * (IKsin(j7)))) + (((-1.0) * x76 * x78)) + ((sj6 * x79)));
                    evalcond[1] =
                        (((r02 * x76)) + ((x75 * x77)) + (((-1.0) * sj5 * x73)) + (((-1.0) * cj8 * (IKcos(j7))))
                            + ((x74 * x75)) + ((x74 * x78)) + ((x77 * x78)));
                    if (IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH) {
                      continue;
                    }
                  }

                  {
                    std::vector<IkSingleDOFSolutionBase<IkReal>> vinfos(5);
                    vinfos[0].jointtype = 1;
                    vinfos[0].foffset = j4;
                    vinfos[0].indices[0] = _ij4[0];
                    vinfos[0].indices[1] = _ij4[1];
                    vinfos[0].maxsolutions = _nj4;
                    vinfos[1].jointtype = 1;
                    vinfos[1].foffset = j5;
                    vinfos[1].indices[0] = _ij5[0];
                    vinfos[1].indices[1] = _ij5[1];
                    vinfos[1].maxsolutions = _nj5;
                    vinfos[2].jointtype = 1;
                    vinfos[2].foffset = j6;
                    vinfos[2].indices[0] = _ij6[0];
                    vinfos[2].indices[1] = _ij6[1];
                    vinfos[2].maxsolutions = _nj6;
                    vinfos[3].jointtype = 1;
                    vinfos[3].foffset = j7;
                    vinfos[3].indices[0] = _ij7[0];
                    vinfos[3].indices[1] = _ij7[1];
                    vinfos[3].maxsolutions = _nj7;
                    vinfos[4].jointtype = 1;
                    vinfos[4].foffset = j8;
                    vinfos[4].indices[0] = _ij8[0];
                    vinfos[4].indices[1] = _ij8[1];
                    vinfos[4].maxsolutions = _nj8;
                    std::vector<int> vfree(0);
                    solutions.AddSolution(vinfos, vfree);
                  }
                }
              }

            }

          }
        }
      }
    }
  }
};

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal *eetrans,
                          const IkReal *eerot,
                          const IkReal *pfree,
                          IkSolutionListBase<IkReal> &solutions) {
  IKSolver solver;
  return solver.ComputeIk(eetrans, eerot, pfree, solutions);
}

IKFAST_API bool ComputeIk2(const IkReal *eetrans,
                           const IkReal *eerot,
                           const IkReal *pfree,
                           IkSolutionListBase<IkReal> &solutions,
                           void *pOpenRAVEManip) {
  IKSolver solver;
  return solver.ComputeIk(eetrans, eerot, pfree, solutions);
}

IKFAST_API const char *GetKinematicsHash() { return "73ccfc84e91dc469ba107503542d7022"; }

IKFAST_API const char *GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char **argv) {
  if (argc != 12 + GetNumFreeParameters() + 1) {
    printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
           "Returns the ik solutions given the transformation of the end effector specified by\n"
           "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
           "There are %d free parameters that have to be specified.\n\n", GetNumFreeParameters());
    return 1;
  }

  IkSolutionList<IkReal> solutions;
  std::vector<IkReal> vfree(GetNumFreeParameters());
  IkReal eerot[9], eetrans[3];
  eerot[0] = atof(argv[1]);
  eerot[1] = atof(argv[2]);
  eerot[2] = atof(argv[3]);
  eetrans[0] = atof(argv[4]);
  eerot[3] = atof(argv[5]);
  eerot[4] = atof(argv[6]);
  eerot[5] = atof(argv[7]);
  eetrans[1] = atof(argv[8]);
  eerot[6] = atof(argv[9]);
  eerot[7] = atof(argv[10]);
  eerot[8] = atof(argv[11]);
  eetrans[2] = atof(argv[12]);
  for (std::size_t i = 0; i < vfree.size(); ++i)
    vfree[i] = atof(argv[13 + i]);
  bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

  if (!bSuccess) {
    fprintf(stderr, "Failed to get ik solution\n");
    return -1;
  }

  printf("Found %d ik solutions:\n", (int) solutions.GetNumSolutions());
  std::vector<IkReal> solvalues(GetNumJoints());
  for (std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
    const IkSolutionBase<IkReal> &sol = solutions.GetSolution(i);
    printf("sol%d (free=%d): ", (int) i, (int) sol.GetFree().size());
    std::vector<IkReal> vsolfree(sol.GetFree().size());
    sol.GetSolution(&solvalues[0], vsolfree.size() > 0 ? &vsolfree[0] : NULL);
    for (std::size_t j = 0; j < solvalues.size(); ++j)
      printf("%.15f, ", solvalues[j]);
    printf("\n");
  }
  return 0;
}

#endif
